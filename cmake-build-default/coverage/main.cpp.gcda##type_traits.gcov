        -:    0:Source:/Library/Developer/CommandLineTools/SDKs/MacOSX12.1.sdk/usr/include/c++/v1/type_traits
        -:    0:Graph:/Users/maxbazarov/Documents/Software_testing/ctest/cmake-build-default/tests/CMakeFiles/ctest-tests.dir/main.cpp.gcno
        -:    0:Data:/Users/maxbazarov/Documents/Software_testing/ctest/cmake-build-default/tests/CMakeFiles/ctest-tests.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===------------------------ type_traits ---------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_TYPE_TRAITS
        -:   11:#define _LIBCPP_TYPE_TRAITS
        -:   12:
        -:   13:/*
        -:   14:    type_traits synopsis
        -:   15:
        -:   16:namespace std
        -:   17:{
        -:   18:
        -:   19:    // helper class:
        -:   20:    template <class T, T v> struct integral_constant;
        -:   21:    typedef integral_constant<bool, true>  true_type;   // C++11
        -:   22:    typedef integral_constant<bool, false> false_type;  // C++11
        -:   23:
        -:   24:    template <bool B>                                   // C++14
        -:   25:    using bool_constant = integral_constant<bool, B>;   // C++14
        -:   26:    typedef bool_constant<true> true_type;              // C++14
        -:   27:    typedef bool_constant<false> false_type;            // C++14
        -:   28:
        -:   29:    // helper traits
        -:   30:    template <bool, class T = void> struct enable_if;
        -:   31:    template <bool, class T, class F> struct conditional;
        -:   32:
        -:   33:    // Primary classification traits:
        -:   34:    template <class T> struct is_void;
        -:   35:    template <class T> struct is_null_pointer;  // C++14
        -:   36:    template <class T> struct is_integral;
        -:   37:    template <class T> struct is_floating_point;
        -:   38:    template <class T> struct is_array;
        -:   39:    template <class T> struct is_pointer;
        -:   40:    template <class T> struct is_lvalue_reference;
        -:   41:    template <class T> struct is_rvalue_reference;
        -:   42:    template <class T> struct is_member_object_pointer;
        -:   43:    template <class T> struct is_member_function_pointer;
        -:   44:    template <class T> struct is_enum;
        -:   45:    template <class T> struct is_union;
        -:   46:    template <class T> struct is_class;
        -:   47:    template <class T> struct is_function;
        -:   48:
        -:   49:    // Secondary classification traits:
        -:   50:    template <class T> struct is_reference;
        -:   51:    template <class T> struct is_arithmetic;
        -:   52:    template <class T> struct is_fundamental;
        -:   53:    template <class T> struct is_member_pointer;
        -:   54:    template <class T> struct is_scoped_enum; // C++2b
        -:   55:    template <class T> struct is_scalar;
        -:   56:    template <class T> struct is_object;
        -:   57:    template <class T> struct is_compound;
        -:   58:
        -:   59:    // Const-volatile properties and transformations:
        -:   60:    template <class T> struct is_const;
        -:   61:    template <class T> struct is_volatile;
        -:   62:    template <class T> struct remove_const;
        -:   63:    template <class T> struct remove_volatile;
        -:   64:    template <class T> struct remove_cv;
        -:   65:    template <class T> struct add_const;
        -:   66:    template <class T> struct add_volatile;
        -:   67:    template <class T> struct add_cv;
        -:   68:
        -:   69:    // Reference transformations:
        -:   70:    template <class T> struct remove_reference;
        -:   71:    template <class T> struct add_lvalue_reference;
        -:   72:    template <class T> struct add_rvalue_reference;
        -:   73:
        -:   74:    // Pointer transformations:
        -:   75:    template <class T> struct remove_pointer;
        -:   76:    template <class T> struct add_pointer;
        -:   77:
        -:   78:    template<class T> struct type_identity;                     // C++20
        -:   79:    template<class T>
        -:   80:      using type_identity_t = typename type_identity<T>::type;  // C++20
        -:   81:
        -:   82:    // Integral properties:
        -:   83:    template <class T> struct is_signed;
        -:   84:    template <class T> struct is_unsigned;
        -:   85:    template <class T> struct make_signed;
        -:   86:    template <class T> struct make_unsigned;
        -:   87:
        -:   88:    // Array properties and transformations:
        -:   89:    template <class T> struct rank;
        -:   90:    template <class T, unsigned I = 0> struct extent;
        -:   91:    template <class T> struct remove_extent;
        -:   92:    template <class T> struct remove_all_extents;
        -:   93:
        -:   94:    template <class T> struct is_bounded_array;                 // C++20
        -:   95:    template <class T> struct is_unbounded_array;               // C++20
        -:   96:
        -:   97:    // Member introspection:
        -:   98:    template <class T> struct is_pod;
        -:   99:    template <class T> struct is_trivial;
        -:  100:    template <class T> struct is_trivially_copyable;
        -:  101:    template <class T> struct is_standard_layout;
        -:  102:    template <class T> struct is_literal_type;
        -:  103:    template <class T> struct is_empty;
        -:  104:    template <class T> struct is_polymorphic;
        -:  105:    template <class T> struct is_abstract;
        -:  106:    template <class T> struct is_final; // C++14
        -:  107:    template <class T> struct is_aggregate; // C++17
        -:  108:
        -:  109:    template <class T, class... Args> struct is_constructible;
        -:  110:    template <class T>                struct is_default_constructible;
        -:  111:    template <class T>                struct is_copy_constructible;
        -:  112:    template <class T>                struct is_move_constructible;
        -:  113:    template <class T, class U>       struct is_assignable;
        -:  114:    template <class T>                struct is_copy_assignable;
        -:  115:    template <class T>                struct is_move_assignable;
        -:  116:    template <class T, class U>       struct is_swappable_with;       // C++17
        -:  117:    template <class T>                struct is_swappable;            // C++17
        -:  118:    template <class T>                struct is_destructible;
        -:  119:
        -:  120:    template <class T, class... Args> struct is_trivially_constructible;
        -:  121:    template <class T>                struct is_trivially_default_constructible;
        -:  122:    template <class T>                struct is_trivially_copy_constructible;
        -:  123:    template <class T>                struct is_trivially_move_constructible;
        -:  124:    template <class T, class U>       struct is_trivially_assignable;
        -:  125:    template <class T>                struct is_trivially_copy_assignable;
        -:  126:    template <class T>                struct is_trivially_move_assignable;
        -:  127:    template <class T>                struct is_trivially_destructible;
        -:  128:
        -:  129:    template <class T, class... Args> struct is_nothrow_constructible;
        -:  130:    template <class T>                struct is_nothrow_default_constructible;
        -:  131:    template <class T>                struct is_nothrow_copy_constructible;
        -:  132:    template <class T>                struct is_nothrow_move_constructible;
        -:  133:    template <class T, class U>       struct is_nothrow_assignable;
        -:  134:    template <class T>                struct is_nothrow_copy_assignable;
        -:  135:    template <class T>                struct is_nothrow_move_assignable;
        -:  136:    template <class T, class U>       struct is_nothrow_swappable_with; // C++17
        -:  137:    template <class T>                struct is_nothrow_swappable;      // C++17
        -:  138:    template <class T>                struct is_nothrow_destructible;
        -:  139:
        -:  140:    template <class T> struct has_virtual_destructor;
        -:  141:
        -:  142:    template<class T> struct has_unique_object_representations;         // C++17
        -:  143:
        -:  144:    // Relationships between types:
        -:  145:    template <class T, class U> struct is_same;
        -:  146:    template <class Base, class Derived> struct is_base_of;
        -:  147:
        -:  148:    template <class From, class To> struct is_convertible;
        -:  149:    template <typename From, typename To> struct is_nothrow_convertible;                  // C++20
        -:  150:    template <typename From, typename To> inline constexpr bool is_nothrow_convertible_v; // C++20
        -:  151:
        -:  152:    template <class Fn, class... ArgTypes> struct is_invocable;
        -:  153:    template <class R, class Fn, class... ArgTypes> struct is_invocable_r;
        -:  154:
        -:  155:    template <class Fn, class... ArgTypes> struct is_nothrow_invocable;
        -:  156:    template <class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;
        -:  157:
        -:  158:    // Alignment properties and transformations:
        -:  159:    template <class T> struct alignment_of;
        -:  160:    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
        -:  161:        struct aligned_storage;
        -:  162:    template <size_t Len, class... Types> struct aligned_union;
        -:  163:    template <class T> struct remove_cvref; // C++20
        -:  164:
        -:  165:    template <class T> struct decay;
        -:  166:    template <class... T> struct common_type;
        -:  167:    template <class T> struct underlying_type;
        -:  168:    template <class> class result_of; // undefined
        -:  169:    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;
        -:  170:    template <class Fn, class... ArgTypes> struct invoke_result;  // C++17
        -:  171:
        -:  172:    // const-volatile modifications:
        -:  173:    template <class T>
        -:  174:      using remove_const_t    = typename remove_const<T>::type;  // C++14
        -:  175:    template <class T>
        -:  176:      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
        -:  177:    template <class T>
        -:  178:      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
        -:  179:    template <class T>
        -:  180:      using add_const_t       = typename add_const<T>::type;  // C++14
        -:  181:    template <class T>
        -:  182:      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
        -:  183:    template <class T>
        -:  184:      using add_cv_t          = typename add_cv<T>::type;  // C++14
        -:  185:
        -:  186:    // reference modifications:
        -:  187:    template <class T>
        -:  188:      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
        -:  189:    template <class T>
        -:  190:      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
        -:  191:    template <class T>
        -:  192:      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14
        -:  193:
        -:  194:    // sign modifications:
        -:  195:    template <class T>
        -:  196:      using make_signed_t   = typename make_signed<T>::type;  // C++14
        -:  197:    template <class T>
        -:  198:      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14
        -:  199:
        -:  200:    // array modifications:
        -:  201:    template <class T>
        -:  202:      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
        -:  203:    template <class T>
        -:  204:      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14
        -:  205:
        -:  206:    template <class T>
        -:  207:      inline constexpr bool is_bounded_array_v
        -:  208:        = is_bounded_array<T>::value;                                     // C++20
        -:  209:      inline constexpr bool is_unbounded_array_v
        -:  210:        = is_unbounded_array<T>::value;                                   // C++20
        -:  211:
        -:  212:    // pointer modifications:
        -:  213:    template <class T>
        -:  214:      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
        -:  215:    template <class T>
        -:  216:      using add_pointer_t    = typename add_pointer<T>::type;  // C++14
        -:  217:
        -:  218:    // other transformations:
        -:  219:    template <size_t Len, std::size_t Align=default-alignment>
        -:  220:      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
        -:  221:    template <std::size_t Len, class... Types>
        -:  222:      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
        -:  223:    template <class T>
        -:  224:      using remove_cvref_t    = typename remove_cvref<T>::type;  // C++20
        -:  225:    template <class T>
        -:  226:      using decay_t           = typename decay<T>::type;  // C++14
        -:  227:    template <bool b, class T=void>
        -:  228:      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
        -:  229:    template <bool b, class T, class F>
        -:  230:      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
        -:  231:    template <class... T>
        -:  232:      using common_type_t     = typename common_type<T...>::type;  // C++14
        -:  233:    template <class T>
        -:  234:      using underlying_type_t = typename underlying_type<T>::type;  // C++14
        -:  235:    template <class T>
        -:  236:      using result_of_t       = typename result_of<T>::type;  // C++14
        -:  237:    template <class Fn, class... ArgTypes>
        -:  238:      using invoke_result_t   = typename invoke_result<Fn, ArgTypes...>::type;  // C++17
        -:  239:
        -:  240:    template <class...>
        -:  241:      using void_t = void;   // C++17
        -:  242:
        -:  243:      // See C++14 20.10.4.1, primary type categories
        -:  244:      template <class T> inline constexpr bool is_void_v
        -:  245:        = is_void<T>::value;                                             // C++17
        -:  246:      template <class T> inline constexpr bool is_null_pointer_v
        -:  247:        = is_null_pointer<T>::value;                                     // C++17
        -:  248:      template <class T> inline constexpr bool is_integral_v
        -:  249:        = is_integral<T>::value;                                         // C++17
        -:  250:      template <class T> inline constexpr bool is_floating_point_v
        -:  251:        = is_floating_point<T>::value;                                   // C++17
        -:  252:      template <class T> inline constexpr bool is_array_v
        -:  253:        = is_array<T>::value;                                            // C++17
        -:  254:      template <class T> inline constexpr bool is_pointer_v
        -:  255:        = is_pointer<T>::value;                                          // C++17
        -:  256:      template <class T> inline constexpr bool is_lvalue_reference_v
        -:  257:        = is_lvalue_reference<T>::value;                                 // C++17
        -:  258:      template <class T> inline constexpr bool is_rvalue_reference_v
        -:  259:        = is_rvalue_reference<T>::value;                                 // C++17
        -:  260:      template <class T> inline constexpr bool is_member_object_pointer_v
        -:  261:        = is_member_object_pointer<T>::value;                            // C++17
        -:  262:      template <class T> inline constexpr bool is_member_function_pointer_v
        -:  263:        = is_member_function_pointer<T>::value;                          // C++17
        -:  264:      template <class T> inline constexpr bool is_enum_v
        -:  265:        = is_enum<T>::value;                                             // C++17
        -:  266:      template <class T> inline constexpr bool is_union_v
        -:  267:        = is_union<T>::value;                                            // C++17
        -:  268:      template <class T> inline constexpr bool is_class_v
        -:  269:        = is_class<T>::value;                                            // C++17
        -:  270:      template <class T> inline constexpr bool is_function_v
        -:  271:        = is_function<T>::value;                                         // C++17
        -:  272:
        -:  273:      // See C++14 20.10.4.2, composite type categories
        -:  274:      template <class T> inline constexpr bool is_reference_v
        -:  275:        = is_reference<T>::value;                                        // C++17
        -:  276:      template <class T> inline constexpr bool is_arithmetic_v
        -:  277:        = is_arithmetic<T>::value;                                       // C++17
        -:  278:      template <class T> inline constexpr bool is_fundamental_v
        -:  279:        = is_fundamental<T>::value;                                      // C++17
        -:  280:      template <class T> inline constexpr bool is_object_v
        -:  281:        = is_object<T>::value;                                           // C++17
        -:  282:      template <class T> inline constexpr bool is_scalar_v
        -:  283:        = is_scalar<T>::value;                                           // C++17
        -:  284:      template <class T> inline constexpr bool is_compound_v
        -:  285:        = is_compound<T>::value;                                         // C++17
        -:  286:      template <class T> inline constexpr bool is_member_pointer_v
        -:  287:        = is_member_pointer<T>::value;                                   // C++17
        -:  288:      template <class T> inline constexpr bool is_scoped_enum_v
        -:  289:        = is_scoped_enum<T>::value;                                      // C++2b
        -:  290:
        -:  291:      // See C++14 20.10.4.3, type properties
        -:  292:      template <class T> inline constexpr bool is_const_v
        -:  293:        = is_const<T>::value;                                            // C++17
        -:  294:      template <class T> inline constexpr bool is_volatile_v
        -:  295:        = is_volatile<T>::value;                                         // C++17
        -:  296:      template <class T> inline constexpr bool is_trivial_v
        -:  297:        = is_trivial<T>::value;                                          // C++17
        -:  298:      template <class T> inline constexpr bool is_trivially_copyable_v
        -:  299:        = is_trivially_copyable<T>::value;                               // C++17
        -:  300:      template <class T> inline constexpr bool is_standard_layout_v
        -:  301:        = is_standard_layout<T>::value;                                  // C++17
        -:  302:      template <class T> inline constexpr bool is_pod_v
        -:  303:        = is_pod<T>::value;                                              // C++17
        -:  304:      template <class T> inline constexpr bool is_literal_type_v
        -:  305:        = is_literal_type<T>::value;                                     // C++17
        -:  306:      template <class T> inline constexpr bool is_empty_v
        -:  307:        = is_empty<T>::value;                                            // C++17
        -:  308:      template <class T> inline constexpr bool is_polymorphic_v
        -:  309:        = is_polymorphic<T>::value;                                      // C++17
        -:  310:      template <class T> inline constexpr bool is_abstract_v
        -:  311:        = is_abstract<T>::value;                                         // C++17
        -:  312:      template <class T> inline constexpr bool is_final_v
        -:  313:        = is_final<T>::value;                                            // C++17
        -:  314:      template <class T> inline constexpr bool is_aggregate_v
        -:  315:        = is_aggregate<T>::value;                                        // C++17
        -:  316:      template <class T> inline constexpr bool is_signed_v
        -:  317:        = is_signed<T>::value;                                           // C++17
        -:  318:      template <class T> inline constexpr bool is_unsigned_v
        -:  319:        = is_unsigned<T>::value;                                         // C++17
        -:  320:      template <class T, class... Args> inline constexpr bool is_constructible_v
        -:  321:        = is_constructible<T, Args...>::value;                           // C++17
        -:  322:      template <class T> inline constexpr bool is_default_constructible_v
        -:  323:        = is_default_constructible<T>::value;                            // C++17
        -:  324:      template <class T> inline constexpr bool is_copy_constructible_v
        -:  325:        = is_copy_constructible<T>::value;                               // C++17
        -:  326:      template <class T> inline constexpr bool is_move_constructible_v
        -:  327:        = is_move_constructible<T>::value;                               // C++17
        -:  328:      template <class T, class U> inline constexpr bool is_assignable_v
        -:  329:        = is_assignable<T, U>::value;                                    // C++17
        -:  330:      template <class T> inline constexpr bool is_copy_assignable_v
        -:  331:        = is_copy_assignable<T>::value;                                  // C++17
        -:  332:      template <class T> inline constexpr bool is_move_assignable_v
        -:  333:        = is_move_assignable<T>::value;                                  // C++17
        -:  334:      template <class T, class U> inline constexpr bool is_swappable_with_v
        -:  335:        = is_swappable_with<T, U>::value;                                // C++17
        -:  336:      template <class T> inline constexpr bool is_swappable_v
        -:  337:        = is_swappable<T>::value;                                        // C++17
        -:  338:      template <class T> inline constexpr bool is_destructible_v
        -:  339:        = is_destructible<T>::value;                                     // C++17
        -:  340:      template <class T, class... Args> inline constexpr bool is_trivially_constructible_v
        -:  341:        = is_trivially_constructible<T, Args...>::value;                 // C++17
        -:  342:      template <class T> inline constexpr bool is_trivially_default_constructible_v
        -:  343:        = is_trivially_default_constructible<T>::value;                  // C++17
        -:  344:      template <class T> inline constexpr bool is_trivially_copy_constructible_v
        -:  345:        = is_trivially_copy_constructible<T>::value;                     // C++17
        -:  346:      template <class T> inline constexpr bool is_trivially_move_constructible_v
        -:  347:        = is_trivially_move_constructible<T>::value;                     // C++17
        -:  348:      template <class T, class U> inline constexpr bool is_trivially_assignable_v
        -:  349:        = is_trivially_assignable<T, U>::value;                          // C++17
        -:  350:      template <class T> inline constexpr bool is_trivially_copy_assignable_v
        -:  351:        = is_trivially_copy_assignable<T>::value;                        // C++17
        -:  352:      template <class T> inline constexpr bool is_trivially_move_assignable_v
        -:  353:        = is_trivially_move_assignable<T>::value;                        // C++17
        -:  354:      template <class T> inline constexpr bool is_trivially_destructible_v
        -:  355:        = is_trivially_destructible<T>::value;                           // C++17
        -:  356:      template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v
        -:  357:        = is_nothrow_constructible<T, Args...>::value;                   // C++17
        -:  358:      template <class T> inline constexpr bool is_nothrow_default_constructible_v
        -:  359:        = is_nothrow_default_constructible<T>::value;                    // C++17
        -:  360:      template <class T> inline constexpr bool is_nothrow_copy_constructible_v
        -:  361:        = is_nothrow_copy_constructible<T>::value;                       // C++17
        -:  362:      template <class T> inline constexpr bool is_nothrow_move_constructible_v
        -:  363:        = is_nothrow_move_constructible<T>::value;                       // C++17
        -:  364:      template <class T, class U> inline constexpr bool is_nothrow_assignable_v
        -:  365:        = is_nothrow_assignable<T, U>::value;                            // C++17
        -:  366:      template <class T> inline constexpr bool is_nothrow_copy_assignable_v
        -:  367:        = is_nothrow_copy_assignable<T>::value;                          // C++17
        -:  368:      template <class T> inline constexpr bool is_nothrow_move_assignable_v
        -:  369:        = is_nothrow_move_assignable<T>::value;                          // C++17
        -:  370:      template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v
        -:  371:        = is_nothrow_swappable_with<T, U>::value;                       // C++17
        -:  372:      template <class T> inline constexpr bool is_nothrow_swappable_v
        -:  373:        = is_nothrow_swappable<T>::value;                               // C++17
        -:  374:      template <class T> inline constexpr bool is_nothrow_destructible_v
        -:  375:        = is_nothrow_destructible<T>::value;                             // C++17
        -:  376:      template <class T> inline constexpr bool has_virtual_destructor_v
        -:  377:        = has_virtual_destructor<T>::value;                              // C++17
        -:  378:      template<class T> inline constexpr bool has_unique_object_representations_v // C++17
        -:  379:        = has_unique_object_representations<T>::value;
        -:  380:
        -:  381:      // See C++14 20.10.5, type property queries
        -:  382:      template <class T> inline constexpr size_t alignment_of_v
        -:  383:        = alignment_of<T>::value;                                        // C++17
        -:  384:      template <class T> inline constexpr size_t rank_v
        -:  385:        = rank<T>::value;                                                // C++17
        -:  386:      template <class T, unsigned I = 0> inline constexpr size_t extent_v
        -:  387:        = extent<T, I>::value;                                           // C++17
        -:  388:
        -:  389:      // See C++14 20.10.6, type relations
        -:  390:      template <class T, class U> inline constexpr bool is_same_v
        -:  391:        = is_same<T, U>::value;                                          // C++17
        -:  392:      template <class Base, class Derived> inline constexpr bool is_base_of_v
        -:  393:        = is_base_of<Base, Derived>::value;                              // C++17
        -:  394:      template <class From, class To> inline constexpr bool is_convertible_v
        -:  395:        = is_convertible<From, To>::value;                               // C++17
        -:  396:      template <class Fn, class... ArgTypes> inline constexpr bool is_invocable_v
        -:  397:        = is_invocable<Fn, ArgTypes...>::value;                          // C++17
        -:  398:      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_invocable_r_v
        -:  399:        = is_invocable_r<R, Fn, ArgTypes...>::value;                     // C++17
        -:  400:      template <class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_v
        -:  401:        = is_nothrow_invocable<Fn, ArgTypes...>::value;                  // C++17
        -:  402:      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_r_v
        -:  403:        = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;             // C++17
        -:  404:
        -:  405:      // [meta.logical], logical operator traits:
        -:  406:      template<class... B> struct conjunction;                           // C++17
        -:  407:      template<class... B>
        -:  408:        inline constexpr bool conjunction_v = conjunction<B...>::value;  // C++17
        -:  409:      template<class... B> struct disjunction;                           // C++17
        -:  410:      template<class... B>
        -:  411:        inline constexpr bool disjunction_v = disjunction<B...>::value;  // C++17
        -:  412:      template<class B> struct negation;                                 // C++17
        -:  413:      template<class B>
        -:  414:        inline constexpr bool negation_v = negation<B>::value;           // C++17
        -:  415:
        -:  416:}
        -:  417:
        -:  418:*/
        -:  419:#include <__config>
        -:  420:#include <cstddef>
        -:  421:#include <version>
        -:  422:
        -:  423:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  424:#pragma GCC system_header
        -:  425:#endif
        -:  426:
        -:  427:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  428:
        -:  429:template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;
        -:  430:template <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;
        -:  431:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;
        -:  432:
        -:  433:template <class _Tp, _Tp __v>
        -:  434:struct _LIBCPP_TEMPLATE_VIS integral_constant
        -:  435:{
        -:  436:  static _LIBCPP_CONSTEXPR const _Tp      value = __v;
        -:  437:  typedef _Tp               value_type;
        -:  438:  typedef integral_constant type;
        -:  439:  _LIBCPP_INLINE_VISIBILITY
        -:  440:  _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}
        -:  441:#if _LIBCPP_STD_VER > 11
        -:  442:  _LIBCPP_INLINE_VISIBILITY
        -:  443:  constexpr value_type operator ()() const _NOEXCEPT {return value;}
        -:  444:#endif
        -:  445:};
        -:  446:
        -:  447:template <class _Tp, _Tp __v>
        -:  448:_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
        -:  449:
        -:  450:#if _LIBCPP_STD_VER > 14
        -:  451:template <bool __b>
        -:  452:using bool_constant = integral_constant<bool, __b>;
        -:  453:#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>
        -:  454:#else
        -:  455:#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>
        -:  456:#endif
        -:  457:
        -:  458:typedef _LIBCPP_BOOL_CONSTANT(true)  true_type;
        -:  459:typedef _LIBCPP_BOOL_CONSTANT(false) false_type;
        -:  460:
        -:  461:template <bool _Val>
        -:  462:using _BoolConstant _LIBCPP_NODEBUG_TYPE = integral_constant<bool, _Val>;
        -:  463:
        -:  464:template <bool> struct _MetaBase;
        -:  465:template <>
        -:  466:struct _MetaBase<true> {
        -:  467:  template <class _Tp, class _Up>
        -:  468:  using _SelectImpl _LIBCPP_NODEBUG_TYPE = _Tp;
        -:  469:  template <template <class...> class _FirstFn, template <class...> class, class ..._Args>
        -:  470:  using _SelectApplyImpl _LIBCPP_NODEBUG_TYPE = _FirstFn<_Args...>;
        -:  471:  template <class _First, class...>
        -:  472:  using _FirstImpl _LIBCPP_NODEBUG_TYPE = _First;
        -:  473:  template <class, class _Second, class...>
        -:  474:  using _SecondImpl _LIBCPP_NODEBUG_TYPE = _Second;
        -:  475:  template <class _Tp = void>
        -:  476:  using _EnableIfImpl _LIBCPP_NODEBUG_TYPE = _Tp;
        -:  477:  template <class _Result, class _First, class ..._Rest>
        -:  478:  using _OrImpl _LIBCPP_NODEBUG_TYPE = typename _MetaBase<_First::value != true && sizeof...(_Rest) != 0>::template _OrImpl<_First, _Rest...>;
        -:  479:  template <class _Result, class _First, class ..._Rest>
        -:  480:  using _AndImpl _LIBCPP_NODEBUG_TYPE = typename _MetaBase<_First::value == true && sizeof...(_Rest) != 0>::template _AndImpl<_First, _Rest...>;
        -:  481:};
        -:  482:
        -:  483:template <>
        -:  484:struct _MetaBase<false> {
        -:  485:  template <class _Tp, class _Up>
        -:  486:  using _SelectImpl _LIBCPP_NODEBUG_TYPE = _Up;
        -:  487:  template <template <class...> class, template <class...> class _SecondFn, class ..._Args>
        -:  488:  using _SelectApplyImpl _LIBCPP_NODEBUG_TYPE = _SecondFn<_Args...>;
        -:  489:  template <class _Result, class ...>
        -:  490:  using _OrImpl _LIBCPP_NODEBUG_TYPE = _Result;
        -:  491:  template <class _Result, class ...>
        -:  492:  using _AndImpl _LIBCPP_NODEBUG_TYPE = _Result;
        -:  493:};
        -:  494:template <bool _Cond, class _Ret = void>
        -:  495:using _EnableIf _LIBCPP_NODEBUG_TYPE = typename _MetaBase<_Cond>::template _EnableIfImpl<_Ret>;
        -:  496:template <bool _Cond, class _IfRes, class _ElseRes>
        -:  497:using _If _LIBCPP_NODEBUG_TYPE = typename _MetaBase<_Cond>::template _SelectImpl<_IfRes, _ElseRes>;
        -:  498:template <class ..._Rest>
        -:  499:using _Or _LIBCPP_NODEBUG_TYPE = typename _MetaBase< sizeof...(_Rest) != 0 >::template _OrImpl<false_type, _Rest...>;
        -:  500:template <class ..._Rest>
        -:  501:using _And _LIBCPP_NODEBUG_TYPE = typename _MetaBase< sizeof...(_Rest) != 0 >::template _AndImpl<true_type, _Rest...>;
        -:  502:template <class _Pred>
        -:  503:struct _Not : _BoolConstant<!_Pred::value> {};
        -:  504:template <class ..._Args>
        -:  505:using _FirstType _LIBCPP_NODEBUG_TYPE = typename _MetaBase<(sizeof...(_Args) >= 1)>::template _FirstImpl<_Args...>;
        -:  506:template <class ..._Args>
        -:  507:using _SecondType _LIBCPP_NODEBUG_TYPE = typename _MetaBase<(sizeof...(_Args) >= 2)>::template _SecondImpl<_Args...>;
        -:  508:
        -:  509:template <template <class...> class _Func, class ..._Args>
        -:  510:struct _Lazy : _Func<_Args...> {};
        -:  511:
        -:  512:// Member detector base
        -:  513:
        -:  514:template <template <class...> class _Templ, class ..._Args, class = _Templ<_Args...> >
        -:  515:true_type __sfinae_test_impl(int);
        -:  516:template <template <class...> class, class ...>
        -:  517:false_type __sfinae_test_impl(...);
        -:  518:
        -:  519:template <template <class ...> class _Templ, class ..._Args>
        -:  520:using _IsValidExpansion _LIBCPP_NODEBUG_TYPE = decltype(__sfinae_test_impl<_Templ, _Args...>(0));
        -:  521:
        -:  522:template <class>
        -:  523:struct __void_t { typedef void type; };
        -:  524:
        -:  525:template <class _Tp>
        -:  526:struct __identity { typedef _Tp type; };
        -:  527:
        -:  528:template <class _Tp, bool>
        -:  529:struct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};
        -:  530:
        -:  531:
        -:  532:template <bool _Bp, class _If, class _Then>
        -:  533:    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};
        -:  534:template <class _If, class _Then>
        -:  535:    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};
        -:  536:
        -:  537:#if _LIBCPP_STD_VER > 11
        -:  538:template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;
        -:  539:#endif
        -:  540:
        -:  541:template <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};
        -:  542:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};
        -:  543:
        -:  544:#if _LIBCPP_STD_VER > 11
        -:  545:template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
        -:  546:#endif
        -:  547:
        -:  548:// is_same
        -:  549:
        -:  550:#if __has_keyword(__is_same)
        -:  551:
        -:  552:template <class _Tp, class _Up>
        -:  553:struct _LIBCPP_TEMPLATE_VIS is_same : _BoolConstant<__is_same(_Tp, _Up)> { };
        -:  554:
        -:  555:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  556:template <class _Tp, class _Up>
        -:  557:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_same_v = __is_same(_Tp, _Up);
        -:  558:#endif
        -:  559:
        -:  560:#else
        -:  561:
        -:  562:template <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};
        -:  563:template <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};
        -:  564:
        -:  565:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  566:template <class _Tp, class _Up>
        -:  567:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_same_v
        -:  568:    = is_same<_Tp, _Up>::value;
        -:  569:#endif
        -:  570:
        -:  571:#endif // __is_same
        -:  572:
        -:  573:template <class _Tp, class _Up>
        -:  574:using _IsSame = _BoolConstant<
        -:  575:#ifdef __clang__
        -:  576:    __is_same(_Tp, _Up)
        -:  577:#else
        -:  578:    _VSTD::is_same<_Tp, _Up>::value
        -:  579:#endif
        -:  580:>;
        -:  581:
        -:  582:template <class _Tp, class _Up>
        -:  583:using _IsNotSame = _BoolConstant<
        -:  584:#ifdef __clang__
        -:  585:    !__is_same(_Tp, _Up)
        -:  586:#else
        -:  587:    !_VSTD::is_same<_Tp, _Up>::value
        -:  588:#endif
        -:  589:>;
        -:  590:
        -:  591:
        -:  592:template <class _Tp>
        -:  593:using __test_for_primary_template = _EnableIf<
        -:  594:    _IsSame<_Tp, typename _Tp::__primary_template>::value
        -:  595:  >;
        -:  596:template <class _Tp>
        -:  597:using __is_primary_template = _IsValidExpansion<
        -:  598:    __test_for_primary_template, _Tp
        -:  599:  >;
        -:  600:
        -:  601:struct __two {char __lx[2];};
        -:  602:
        -:  603:// helper class:
        -:  604:
        -:  605:// is_const
        -:  606:
        -:  607:#if __has_keyword(__is_const)
        -:  608:
        -:  609:template <class _Tp>
        -:  610:struct _LIBCPP_TEMPLATE_VIS is_const : _BoolConstant<__is_const(_Tp)> { };
        -:  611:
        -:  612:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  613:template <class _Tp>
        -:  614:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_const_v = __is_const(_Tp);
        -:  615:#endif
        -:  616:
        -:  617:#else
        -:  618:
        -:  619:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};
        -:  620:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};
        -:  621:
        -:  622:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  623:template <class _Tp>
        -:  624:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_const_v
        -:  625:    = is_const<_Tp>::value;
        -:  626:#endif
        -:  627:
        -:  628:#endif // __has_keyword(__is_const)
        -:  629:
        -:  630:// is_volatile
        -:  631:
        -:  632:#if __has_keyword(__is_volatile)
        -:  633:
        -:  634:template <class _Tp>
        -:  635:struct _LIBCPP_TEMPLATE_VIS is_volatile : _BoolConstant<__is_volatile(_Tp)> { };
        -:  636:
        -:  637:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  638:template <class _Tp>
        -:  639:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_volatile_v = __is_volatile(_Tp);
        -:  640:#endif
        -:  641:
        -:  642:#else
        -:  643:
        -:  644:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};
        -:  645:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};
        -:  646:
        -:  647:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  648:template <class _Tp>
        -:  649:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_volatile_v
        -:  650:    = is_volatile<_Tp>::value;
        -:  651:#endif
        -:  652:
        -:  653:#endif // __has_keyword(__is_volatile)
        -:  654:
        -:  655:// remove_const
        -:  656:
        -:  657:#if __has_keyword(__remove_const)
        -:  658:
        -:  659:template <class _Tp>
        -:  660:struct _LIBCPP_TEMPLATE_VIS remove_const {typedef __remove_const(_Tp) type;};
        -:  661:
        -:  662:#if _LIBCPP_STD_VER > 11
        -:  663:template <class _Tp> using remove_const_t = __remove_const(_Tp);
        -:  664:#endif
        -:  665:
        -:  666:#else
        -:  667:
        -:  668:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};
        -:  669:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};
        -:  670:#if _LIBCPP_STD_VER > 11
        -:  671:template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;
        -:  672:#endif
        -:  673:
        -:  674:#endif // __has_keyword(__remove_const)
        -:  675:
        -:  676:// remove_volatile
        -:  677:
        -:  678:#if __has_keyword(__remove_volatile)
        -:  679:
        -:  680:template <class _Tp>
        -:  681:struct _LIBCPP_TEMPLATE_VIS remove_volatile {typedef __remove_volatile(_Tp) type;};
        -:  682:
        -:  683:#if _LIBCPP_STD_VER > 11
        -:  684:template <class _Tp> using remove_volatile_t = __remove_volatile(_Tp);
        -:  685:#endif
        -:  686:
        -:  687:#else
        -:  688:
        -:  689:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};
        -:  690:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};
        -:  691:#if _LIBCPP_STD_VER > 11
        -:  692:template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
        -:  693:#endif
        -:  694:
        -:  695:#endif // __has_keyword(__remove_volatile)
        -:  696:
        -:  697:// remove_cv
        -:  698:
        -:  699:#if __has_keyword(__remove_cv)
        -:  700:
        -:  701:template <class _Tp>
        -:  702:struct _LIBCPP_TEMPLATE_VIS remove_cv {typedef __remove_cv(_Tp) type;};
        -:  703:
        -:  704:#if _LIBCPP_STD_VER > 11
        -:  705:template <class _Tp> using remove_cv_t = __remove_cv(_Tp);
        -:  706:#endif
        -:  707:
        -:  708:#else
        -:  709:
        -:  710:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv
        -:  711:{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};
        -:  712:#if _LIBCPP_STD_VER > 11
        -:  713:template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
        -:  714:#endif
        -:  715:
        -:  716:#endif // __has_keyword(__remove_cv)
        -:  717:
        -:  718:// is_void
        -:  719:
        -:  720:#if __has_keyword(__is_void)
        -:  721:
        -:  722:template <class _Tp>
        -:  723:struct _LIBCPP_TEMPLATE_VIS is_void : _BoolConstant<__is_void(_Tp)> { };
        -:  724:
        -:  725:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  726:template <class _Tp>
        -:  727:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_void_v = __is_void(_Tp);
        -:  728:#endif
        -:  729:
        -:  730:#else
        -:  731:
        -:  732:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void
        -:  733:    : public is_same<typename remove_cv<_Tp>::type, void> {};
        -:  734:
        -:  735:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  736:template <class _Tp>
        -:  737:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_void_v
        -:  738:    = is_void<_Tp>::value;
        -:  739:#endif
        -:  740:
        -:  741:#endif // __has_keyword(__is_void)
        -:  742:
        -:  743:// __is_nullptr_t
        -:  744:
        -:  745:template <class _Tp> struct __is_nullptr_t_impl       : public false_type {};
        -:  746:template <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};
        -:  747:
        -:  748:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t
        -:  749:    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
        -:  750:
        -:  751:#if _LIBCPP_STD_VER > 11
        -:  752:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer
        -:  753:    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
        -:  754:
        -:  755:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  756:template <class _Tp>
        -:  757:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_null_pointer_v
        -:  758:    = is_null_pointer<_Tp>::value;
        -:  759:#endif
        -:  760:#endif // _LIBCPP_STD_VER > 11
        -:  761:
        -:  762:// is_integral
        -:  763:
        -:  764:#if __has_keyword(__is_integral)
        -:  765:
        -:  766:template <class _Tp>
        -:  767:struct _LIBCPP_TEMPLATE_VIS is_integral : _BoolConstant<__is_integral(_Tp)> { };
        -:  768:
        -:  769:#if _LIBCPP_STD_VER > 14
        -:  770:template <class _Tp>
        -:  771:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_integral_v = __is_integral(_Tp);
        -:  772:#endif
        -:  773:
        -:  774:#else
        -:  775:
        -:  776:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral
        -:  777:    : public _BoolConstant<__libcpp_is_integral<typename remove_cv<_Tp>::type>::value> {};
        -:  778:
        -:  779:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  780:template <class _Tp>
        -:  781:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_integral_v
        -:  782:    = is_integral<_Tp>::value;
        -:  783:#endif
        -:  784:
        -:  785:#endif // __has_keyword(__is_integral)
        -:  786:
        -:  787:// is_floating_point
        -:  788:
        -:  789:template <class _Tp> struct __libcpp_is_floating_point              : public false_type {};
        -:  790:template <>          struct __libcpp_is_floating_point<float>       : public true_type {};
        -:  791:template <>          struct __libcpp_is_floating_point<double>      : public true_type {};
        -:  792:template <>          struct __libcpp_is_floating_point<long double> : public true_type {};
        -:  793:
        -:  794:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point
        -:  795:    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
        -:  796:
        -:  797:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  798:template <class _Tp>
        -:  799:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_floating_point_v
        -:  800:    = is_floating_point<_Tp>::value;
        -:  801:#endif
        -:  802:
        -:  803:// is_array
        -:  804:
        -:  805:#if __has_keyword(__is_array)
        -:  806:
        -:  807:template <class _Tp>
        -:  808:struct _LIBCPP_TEMPLATE_VIS is_array : _BoolConstant<__is_array(_Tp)> { };
        -:  809:
        -:  810:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  811:template <class _Tp>
        -:  812:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_array_v = __is_array(_Tp);
        -:  813:#endif
        -:  814:
        -:  815:#else
        -:  816:
        -:  817:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array
        -:  818:    : public false_type {};
        -:  819:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>
        -:  820:    : public true_type {};
        -:  821:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>
        -:  822:    : public true_type {};
        -:  823:
        -:  824:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  825:template <class _Tp>
        -:  826:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_array_v
        -:  827:    = is_array<_Tp>::value;
        -:  828:#endif
        -:  829:
        -:  830:#endif // __has_keyword(__is_array)
        -:  831:
        -:  832:// is_pointer
        -:  833:
        -:  834:// In clang 10.0.0 and earlier __is_pointer didn't work with Objective-C types.
        -:  835:#if __has_keyword(__is_pointer) && _LIBCPP_CLANG_VER > 1000
        -:  836:
        -:  837:template<class _Tp>
        -:  838:struct _LIBCPP_TEMPLATE_VIS is_pointer : _BoolConstant<__is_pointer(_Tp)> { };
        -:  839:
        -:  840:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  841:template <class _Tp>
        -:  842:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pointer_v = __is_pointer(_Tp);
        -:  843:#endif
        -:  844:
        -:  845:#else // __has_keyword(__is_pointer)
        -:  846:
        -:  847:template <class _Tp> struct __libcpp_is_pointer       : public false_type {};
        -:  848:template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};
        -:  849:
        -:  850:template <class _Tp> struct __libcpp_remove_objc_qualifiers { typedef _Tp type; };
        -:  851:#if defined(_LIBCPP_HAS_OBJC_ARC)
        -:  852:template <class _Tp> struct __libcpp_remove_objc_qualifiers<_Tp __strong> { typedef _Tp type; };
        -:  853:template <class _Tp> struct __libcpp_remove_objc_qualifiers<_Tp __weak> { typedef _Tp type; };
        -:  854:template <class _Tp> struct __libcpp_remove_objc_qualifiers<_Tp __autoreleasing> { typedef _Tp type; };
        -:  855:template <class _Tp> struct __libcpp_remove_objc_qualifiers<_Tp __unsafe_unretained> { typedef _Tp type; };
        -:  856:#endif
        -:  857:
        -:  858:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer
        -:  859:    : public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<typename remove_cv<_Tp>::type>::type> {};
        -:  860:
        -:  861:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  862:template <class _Tp>
        -:  863:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pointer_v
        -:  864:    = is_pointer<_Tp>::value;
        -:  865:#endif
        -:  866:
        -:  867:#endif // __has_keyword(__is_pointer)
        -:  868:
        -:  869:// is_reference
        -:  870:
        -:  871:#if __has_keyword(__is_lvalue_reference) && \
        -:  872:    __has_keyword(__is_rvalue_reference) && \
        -:  873:    __has_keyword(__is_reference)
        -:  874:
        -:  875:template<class _Tp>
        -:  876:struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference : _BoolConstant<__is_lvalue_reference(_Tp)> { };
        -:  877:
        -:  878:template<class _Tp>
        -:  879:struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference : _BoolConstant<__is_rvalue_reference(_Tp)> { };
        -:  880:
        -:  881:template<class _Tp>
        -:  882:struct _LIBCPP_TEMPLATE_VIS is_reference : _BoolConstant<__is_reference(_Tp)> { };
        -:  883:
        -:  884:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  885:template <class _Tp>
        -:  886:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_reference_v = __is_reference(_Tp);
        -:  887:
        -:  888:template <class _Tp>
        -:  889:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_lvalue_reference_v = __is_lvalue_reference(_Tp);
        -:  890:
        -:  891:template <class _Tp>
        -:  892:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_rvalue_reference_v = __is_rvalue_reference(_Tp);
        -:  893:#endif
        -:  894:
        -:  895:#else // __has_keyword(__is_lvalue_reference) && etc...
        -:  896:
        -:  897:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};
        -:  898:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};
        -:  899:
        -:  900:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};
        -:  901:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};
        -:  902:
        -:  903:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};
        -:  904:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};
        -:  905:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};
        -:  906:
        -:  907:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  908:template <class _Tp>
        -:  909:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_reference_v
        -:  910:    = is_reference<_Tp>::value;
        -:  911:
        -:  912:template <class _Tp>
        -:  913:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_lvalue_reference_v
        -:  914:    = is_lvalue_reference<_Tp>::value;
        -:  915:
        -:  916:template <class _Tp>
        -:  917:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_rvalue_reference_v
        -:  918:    = is_rvalue_reference<_Tp>::value;
        -:  919:#endif
        -:  920:
        -:  921:#endif // __has_keyword(__is_lvalue_reference) && etc...
        -:  922:
        -:  923:// is_union
        -:  924:
        -:  925:#if __has_feature(is_union) || defined(_LIBCPP_COMPILER_GCC)
        -:  926:
        -:  927:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union
        -:  928:    : public integral_constant<bool, __is_union(_Tp)> {};
        -:  929:
        -:  930:#else
        -:  931:
        -:  932:template <class _Tp> struct __libcpp_union : public false_type {};
        -:  933:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union
        -:  934:    : public __libcpp_union<typename remove_cv<_Tp>::type> {};
        -:  935:
        -:  936:#endif
        -:  937:
        -:  938:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  939:template <class _Tp>
        -:  940:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_union_v
        -:  941:    = is_union<_Tp>::value;
        -:  942:#endif
        -:  943:
        -:  944:// is_class
        -:  945:
        -:  946:#if __has_feature(is_class) || defined(_LIBCPP_COMPILER_GCC)
        -:  947:
        -:  948:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class
        -:  949:    : public integral_constant<bool, __is_class(_Tp)> {};
        -:  950:
        -:  951:#else
        -:  952:
        -:  953:namespace __is_class_imp
        -:  954:{
        -:  955:template <class _Tp> char  __test(int _Tp::*);
        -:  956:template <class _Tp> __two __test(...);
        -:  957:}
        -:  958:
        -:  959:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class
        -:  960:    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};
        -:  961:
        -:  962:#endif
        -:  963:
        -:  964:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  965:template <class _Tp>
        -:  966:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_class_v
        -:  967:    = is_class<_Tp>::value;
        -:  968:#endif
        -:  969:
        -:  970:// is_function
        -:  971:
        -:  972:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function
        -:  973:    : public _BoolConstant<
        -:  974:#ifdef __clang__
        -:  975:    __is_function(_Tp)
        -:  976:#else
        -:  977: !(is_reference<_Tp>::value || is_const<const _Tp>::value)
        -:  978:#endif
        -:  979:    > {};
        -:  980:
        -:  981:
        -:  982:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -:  983:template <class _Tp>
        -:  984:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_function_v
        -:  985:    = is_function<_Tp>::value;
        -:  986:#endif
        -:  987:
        -:  988:template <class _Tp> struct __libcpp_is_member_pointer {
        -:  989:  enum {
        -:  990:    __is_member = false,
        -:  991:    __is_func = false,
        -:  992:    __is_obj = false
        -:  993:  };
        -:  994:};
        -:  995:template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> {
        -:  996:  enum {
        -:  997:    __is_member = true,
        -:  998:    __is_func = is_function<_Tp>::value,
        -:  999:    __is_obj = !__is_func,
        -: 1000:  };
        -: 1001:};
        -: 1002:
        -: 1003:#if __has_keyword(__is_member_function_pointer)
        -: 1004:
        -: 1005:template<class _Tp>
        -: 1006:struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer
        -: 1007:    : _BoolConstant<__is_member_function_pointer(_Tp)> { };
        -: 1008:
        -: 1009:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1010:template <class _Tp>
        -: 1011:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_function_pointer_v
        -: 1012:    = __is_member_function_pointer(_Tp);
        -: 1013:#endif
        -: 1014:
        -: 1015:#else // __has_keyword(__is_member_function_pointer)
        -: 1016:
        -: 1017:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer
        -: 1018:    : public _BoolConstant< __libcpp_is_member_pointer<typename remove_cv<_Tp>::type>::__is_func > {};
        -: 1019:
        -: 1020:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1021:template <class _Tp>
        -: 1022:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_function_pointer_v
        -: 1023:    = is_member_function_pointer<_Tp>::value;
        -: 1024:#endif
        -: 1025:
        -: 1026:#endif // __has_keyword(__is_member_function_pointer)
        -: 1027:
        -: 1028:// is_member_pointer
        -: 1029:
        -: 1030:#if __has_keyword(__is_member_pointer)
        -: 1031:
        -: 1032:template<class _Tp>
        -: 1033:struct _LIBCPP_TEMPLATE_VIS is_member_pointer : _BoolConstant<__is_member_pointer(_Tp)> { };
        -: 1034:
        -: 1035:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1036:template <class _Tp>
        -: 1037:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_pointer_v = __is_member_pointer(_Tp);
        -: 1038:#endif
        -: 1039:
        -: 1040:#else // __has_keyword(__is_member_pointer)
        -: 1041:
        -: 1042:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer
        -: 1043: : public _BoolConstant< __libcpp_is_member_pointer<typename remove_cv<_Tp>::type>::__is_member > {};
        -: 1044:
        -: 1045:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1046:template <class _Tp>
        -: 1047:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_pointer_v
        -: 1048:    = is_member_pointer<_Tp>::value;
        -: 1049:#endif
        -: 1050:
        -: 1051:#endif // __has_keyword(__is_member_pointer)
        -: 1052:
        -: 1053:// is_member_object_pointer
        -: 1054:
        -: 1055:#if __has_keyword(__is_member_object_pointer)
        -: 1056:
        -: 1057:template<class _Tp>
        -: 1058:struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer
        -: 1059:    : _BoolConstant<__is_member_object_pointer(_Tp)> { };
        -: 1060:
        -: 1061:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1062:template <class _Tp>
        -: 1063:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_object_pointer_v
        -: 1064:    = __is_member_object_pointer(_Tp);
        -: 1065:#endif
        -: 1066:
        -: 1067:#else // __has_keyword(__is_member_object_pointer)
        -: 1068:
        -: 1069:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer
        -: 1070:    : public _BoolConstant< __libcpp_is_member_pointer<typename remove_cv<_Tp>::type>::__is_obj >  {};
        -: 1071:
        -: 1072:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1073:template <class _Tp>
        -: 1074:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_object_pointer_v
        -: 1075:    = is_member_object_pointer<_Tp>::value;
        -: 1076:#endif
        -: 1077:
        -: 1078:#endif // __has_keyword(__is_member_object_pointer)
        -: 1079:
        -: 1080:// is_enum
        -: 1081:
        -: 1082:#if __has_feature(is_enum) || defined(_LIBCPP_COMPILER_GCC)
        -: 1083:
        -: 1084:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum
        -: 1085:    : public integral_constant<bool, __is_enum(_Tp)> {};
        -: 1086:
        -: 1087:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1088:template <class _Tp>
        -: 1089:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_enum_v = __is_enum(_Tp);
        -: 1090:#endif
        -: 1091:
        -: 1092:#else
        -: 1093:
        -: 1094:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum
        -: 1095:    : public integral_constant<bool, !is_void<_Tp>::value             &&
        -: 1096:                                     !is_integral<_Tp>::value         &&
        -: 1097:                                     !is_floating_point<_Tp>::value   &&
        -: 1098:                                     !is_array<_Tp>::value            &&
        -: 1099:                                     !is_pointer<_Tp>::value          &&
        -: 1100:                                     !is_reference<_Tp>::value        &&
        -: 1101:                                     !is_member_pointer<_Tp>::value   &&
        -: 1102:                                     !is_union<_Tp>::value            &&
        -: 1103:                                     !is_class<_Tp>::value            &&
        -: 1104:                                     !is_function<_Tp>::value         > {};
        -: 1105:
        -: 1106:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1107:template <class _Tp>
        -: 1108:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_enum_v
        -: 1109:    = is_enum<_Tp>::value;
        -: 1110:#endif
        -: 1111:
        -: 1112:#endif // __has_feature(is_enum) || defined(_LIBCPP_COMPILER_GCC)
        -: 1113:
        -: 1114:// is_arithmetic
        -: 1115:
        -: 1116:
        -: 1117:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic
        -: 1118:    : public integral_constant<bool, is_integral<_Tp>::value      ||
        -: 1119:                                     is_floating_point<_Tp>::value> {};
        -: 1120:
        -: 1121:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1122:template <class _Tp>
        -: 1123:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_arithmetic_v
        -: 1124:    = is_arithmetic<_Tp>::value;
        -: 1125:#endif
        -: 1126:
        -: 1127:// is_fundamental
        -: 1128:
        -: 1129:// In clang 9 and lower, this builtin did not work for nullptr_t. Additionally, in C++03 mode,
        -: 1130:// nullptr isn't defined by the compiler so, this builtin won't work.
        -: 1131:#if __has_keyword(__is_fundamental) && _LIBCPP_CLANG_VER > 900 && !defined(_LIBCPP_CXX03_LANG)
        -: 1132:
        -: 1133:template<class _Tp>
        -: 1134:struct _LIBCPP_TEMPLATE_VIS is_fundamental : _BoolConstant<__is_fundamental(_Tp)> { };
        -: 1135:
        -: 1136:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1137:template <class _Tp>
        -: 1138:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_fundamental_v = __is_fundamental(_Tp);
        -: 1139:#endif
        -: 1140:
        -: 1141:#else // __has_keyword(__is_fundamental)
        -: 1142:
        -: 1143:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental
        -: 1144:    : public integral_constant<bool, is_void<_Tp>::value        ||
        -: 1145:                                     __is_nullptr_t<_Tp>::value ||
        -: 1146:                                     is_arithmetic<_Tp>::value> {};
        -: 1147:
        -: 1148:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1149:template <class _Tp>
        -: 1150:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_fundamental_v
        -: 1151:    = is_fundamental<_Tp>::value;
        -: 1152:#endif
        -: 1153:
        -: 1154:#endif // __has_keyword(__is_fundamental)
        -: 1155:
        -: 1156:// is_scalar
        -: 1157:
        -: 1158:// >= 11 because in C++03 nullptr isn't actually nullptr
        -: 1159:#if __has_keyword(__is_scalar) && !defined(_LIBCPP_CXX03_LANG)
        -: 1160:
        -: 1161:template<class _Tp>
        -: 1162:struct _LIBCPP_TEMPLATE_VIS is_scalar : _BoolConstant<__is_scalar(_Tp)> { };
        -: 1163:
        -: 1164:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1165:template <class _Tp>
        -: 1166:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_scalar_v = __is_scalar(_Tp);
        -: 1167:#endif
        -: 1168:
        -: 1169:#else // __has_keyword(__is_scalar)
        -: 1170:
        -: 1171:template <class _Tp> struct __is_block : false_type {};
        -: 1172:#if defined(_LIBCPP_HAS_EXTENSION_BLOCKS)
        -: 1173:template <class _Rp, class ..._Args> struct __is_block<_Rp (^)(_Args...)> : true_type {};
        -: 1174:#endif
        -: 1175:
        -: 1176:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar
        -: 1177:    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||
        -: 1178:                                     is_member_pointer<_Tp>::value ||
        -: 1179:                                     is_pointer<_Tp>::value        ||
        -: 1180:                                     __is_nullptr_t<_Tp>::value    ||
        -: 1181:                                     __is_block<_Tp>::value        ||
        -: 1182:                                     is_enum<_Tp>::value           > {};
        -: 1183:
        -: 1184:template <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};
        -: 1185:
        -: 1186:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1187:template <class _Tp>
        -: 1188:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_scalar_v
        -: 1189:    = is_scalar<_Tp>::value;
        -: 1190:#endif
        -: 1191:
        -: 1192:#endif // __has_keyword(__is_scalar)
        -: 1193:
        -: 1194:// is_object
        -: 1195:
        -: 1196:#if __has_keyword(__is_object)
        -: 1197:
        -: 1198:template<class _Tp>
        -: 1199:struct _LIBCPP_TEMPLATE_VIS is_object : _BoolConstant<__is_object(_Tp)> { };
        -: 1200:
        -: 1201:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1202:template <class _Tp>
        -: 1203:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_object_v = __is_object(_Tp);
        -: 1204:#endif
        -: 1205:
        -: 1206:#else // __has_keyword(__is_object)
        -: 1207:
        -: 1208:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object
        -: 1209:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 1210:                                     is_array<_Tp>::value  ||
        -: 1211:                                     is_union<_Tp>::value  ||
        -: 1212:                                     is_class<_Tp>::value  > {};
        -: 1213:
        -: 1214:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1215:template <class _Tp>
        -: 1216:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_object_v
        -: 1217:    = is_object<_Tp>::value;
        -: 1218:#endif
        -: 1219:
        -: 1220:#endif // __has_keyword(__is_object)
        -: 1221:
        -: 1222:// is_compound
        -: 1223:
        -: 1224:// >= 11 because in C++03 nullptr isn't actually nullptr
        -: 1225:#if __has_keyword(__is_compound) && !defined(_LIBCPP_CXX03_LANG)
        -: 1226:
        -: 1227:template<class _Tp>
        -: 1228:struct _LIBCPP_TEMPLATE_VIS is_compound : _BoolConstant<__is_compound(_Tp)> { };
        -: 1229:
        -: 1230:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1231:template <class _Tp>
        -: 1232:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_compound_v = __is_compound(_Tp);
        -: 1233:#endif
        -: 1234:
        -: 1235:#else // __has_keyword(__is_compound)
        -: 1236:
        -: 1237:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound
        -: 1238:    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
        -: 1239:
        -: 1240:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1241:template <class _Tp>
        -: 1242:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_compound_v
        -: 1243:    = is_compound<_Tp>::value;
        -: 1244:#endif
        -: 1245:
        -: 1246:#endif // __has_keyword(__is_compound)
        -: 1247:
        -: 1248:// __is_referenceable  [defns.referenceable]
        -: 1249:
        -: 1250:struct __is_referenceable_impl {
        -: 1251:    template <class _Tp> static _Tp& __test(int);
        -: 1252:    template <class _Tp> static __two __test(...);
        -: 1253:};
        -: 1254:
        -: 1255:template <class _Tp>
        -: 1256:struct __is_referenceable : integral_constant<bool,
        -: 1257:    _IsNotSame<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};
        -: 1258:
        -: 1259:
        -: 1260:// add_const
        -: 1261:
        -: 1262:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const {
        -: 1263:  typedef _LIBCPP_NODEBUG_TYPE const _Tp type;
        -: 1264:};
        -: 1265:
        -: 1266:#if _LIBCPP_STD_VER > 11
        -: 1267:template <class _Tp> using add_const_t = typename add_const<_Tp>::type;
        -: 1268:#endif
        -: 1269:
        -: 1270:// add_volatile
        -: 1271:
        -: 1272:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile {
        -: 1273:  typedef _LIBCPP_NODEBUG_TYPE volatile _Tp type;
        -: 1274:};
        -: 1275:
        -: 1276:#if _LIBCPP_STD_VER > 11
        -: 1277:template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
        -: 1278:#endif
        -: 1279:
        -: 1280:// add_cv
        -: 1281:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv {
        -: 1282:  typedef _LIBCPP_NODEBUG_TYPE const volatile _Tp type;
        -: 1283:};
        -: 1284:
        -: 1285:#if _LIBCPP_STD_VER > 11
        -: 1286:template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;
        -: 1287:#endif
        -: 1288:
        -: 1289:// remove_reference
        -: 1290:
        -: 1291:#if __has_keyword(__remove_reference)
        -: 1292:
        -: 1293:template<class _Tp>
        -: 1294:struct _LIBCPP_TEMPLATE_VIS remove_reference { typedef __remove_reference(_Tp) type; };
        -: 1295:
        -: 1296:#else // __has_keyword(__remove_reference)
        -: 1297:
        -: 1298:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _LIBCPP_NODEBUG_TYPE _Tp type;};
        -: 1299:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _LIBCPP_NODEBUG_TYPE _Tp type;};
        -: 1300:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _LIBCPP_NODEBUG_TYPE _Tp type;};
        -: 1301:
        -: 1302:#if _LIBCPP_STD_VER > 11
        -: 1303:template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
        -: 1304:#endif
        -: 1305:
        -: 1306:#endif // __has_keyword(__remove_reference)
        -: 1307:
        -: 1308:// add_lvalue_reference
        -: 1309:
        -: 1310:template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _LIBCPP_NODEBUG_TYPE _Tp  type; };
        -: 1311:template <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _LIBCPP_NODEBUG_TYPE _Tp& type; };
        -: 1312:
        -: 1313:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference
        -: 1314:{typedef _LIBCPP_NODEBUG_TYPE typename  __add_lvalue_reference_impl<_Tp>::type type;};
        -: 1315:
        -: 1316:#if _LIBCPP_STD_VER > 11
        -: 1317:template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
        -: 1318:#endif
        -: 1319:
        -: 1320:template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _LIBCPP_NODEBUG_TYPE  _Tp   type; };
        -: 1321:template <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _LIBCPP_NODEBUG_TYPE  _Tp&& type; };
        -: 1322:
        -: 1323:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference
        -: 1324:{typedef _LIBCPP_NODEBUG_TYPE  typename __add_rvalue_reference_impl<_Tp>::type type;};
        -: 1325:
        -: 1326:#if _LIBCPP_STD_VER > 11
        -: 1327:template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
        -: 1328:#endif
        -: 1329:
        -: 1330:// Suppress deprecation notice for volatile-qualified return type resulting
        -: 1331:// from volatile-qualified types _Tp.
        -: 1332:_LIBCPP_SUPPRESS_DEPRECATED_PUSH
        -: 1333:template <class _Tp> _Tp&& __declval(int);
        -: 1334:template <class _Tp> _Tp   __declval(long);
        -: 1335:_LIBCPP_SUPPRESS_DEPRECATED_POP
        -: 1336:
        -: 1337:template <class _Tp>
        -: 1338:decltype(_VSTD::__declval<_Tp>(0))
        -: 1339:declval() _NOEXCEPT;
        -: 1340:
        -: 1341:// __uncvref
        -: 1342:
        -: 1343:template <class _Tp>
        -: 1344:struct __uncvref  {
        -: 1345:    typedef _LIBCPP_NODEBUG_TYPE typename remove_cv<typename remove_reference<_Tp>::type>::type type;
        -: 1346:};
        -: 1347:
        -: 1348:template <class _Tp>
        -: 1349:struct __unconstref {
        -: 1350:    typedef _LIBCPP_NODEBUG_TYPE typename remove_const<typename remove_reference<_Tp>::type>::type type;
        -: 1351:};
        -: 1352:
        -: 1353:#ifndef _LIBCPP_CXX03_LANG
        -: 1354:template <class _Tp>
        -: 1355:using __uncvref_t _LIBCPP_NODEBUG_TYPE = typename __uncvref<_Tp>::type;
        -: 1356:#endif
        -: 1357:
        -: 1358:// __is_same_uncvref
        -: 1359:
        -: 1360:template <class _Tp, class _Up>
        -: 1361:struct __is_same_uncvref : _IsSame<typename __uncvref<_Tp>::type,
        -: 1362:                                   typename __uncvref<_Up>::type> {};
        -: 1363:
        -: 1364:#if _LIBCPP_STD_VER > 17
        -: 1365:// remove_cvref - same as __uncvref
        -: 1366:template <class _Tp>
        -: 1367:struct remove_cvref : public __uncvref<_Tp> {};
        -: 1368:
        -: 1369:template <class _Tp> using remove_cvref_t = typename remove_cvref<_Tp>::type;
        -: 1370:#endif
        -: 1371:
        -: 1372:
        -: 1373:struct __any
        -: 1374:{
        -: 1375:    __any(...);
        -: 1376:};
        -: 1377:
        -: 1378:// remove_pointer
        -: 1379:
        -: 1380:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _LIBCPP_NODEBUG_TYPE _Tp type;};
        -: 1381:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _LIBCPP_NODEBUG_TYPE _Tp type;};
        -: 1382:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _LIBCPP_NODEBUG_TYPE _Tp type;};
        -: 1383:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _LIBCPP_NODEBUG_TYPE _Tp type;};
        -: 1384:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _LIBCPP_NODEBUG_TYPE _Tp type;};
        -: 1385:
        -: 1386:#if _LIBCPP_STD_VER > 11
        -: 1387:template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
        -: 1388:#endif
        -: 1389:
        -: 1390:// add_pointer
        -: 1391:
        -: 1392:template <class _Tp,
        -: 1393:        bool = __is_referenceable<_Tp>::value ||
        -: 1394:                _IsSame<typename remove_cv<_Tp>::type, void>::value>
        -: 1395:struct __add_pointer_impl
        -: 1396:    {typedef _LIBCPP_NODEBUG_TYPE typename remove_reference<_Tp>::type* type;};
        -: 1397:template <class _Tp> struct __add_pointer_impl<_Tp, false>
        -: 1398:    {typedef _LIBCPP_NODEBUG_TYPE _Tp type;};
        -: 1399:
        -: 1400:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer
        -: 1401:    {typedef _LIBCPP_NODEBUG_TYPE typename __add_pointer_impl<_Tp>::type type;};
        -: 1402:
        -: 1403:#if _LIBCPP_STD_VER > 11
        -: 1404:template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
        -: 1405:#endif
        -: 1406:
        -: 1407:// type_identity
        -: 1408:#if _LIBCPP_STD_VER > 17
        -: 1409:template<class _Tp> struct type_identity { typedef _Tp type; };
        -: 1410:template<class _Tp> using type_identity_t = typename type_identity<_Tp>::type;
        -: 1411:#endif
        -: 1412:
        -: 1413:// is_signed
        -: 1414:
        -: 1415:// In clang 9 and earlier, this builtin did not work for floating points or enums
        -: 1416:#if __has_keyword(__is_signed) && _LIBCPP_CLANG_VER > 900
        -: 1417:
        -: 1418:template<class _Tp>
        -: 1419:struct _LIBCPP_TEMPLATE_VIS is_signed : _BoolConstant<__is_signed(_Tp)> { };
        -: 1420:
        -: 1421:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1422:template <class _Tp>
        -: 1423:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_signed_v = __is_signed(_Tp);
        -: 1424:#endif
        -: 1425:
        -: 1426:#else // __has_keyword(__is_signed)
        -: 1427:
        -: 1428:template <class _Tp, bool = is_integral<_Tp>::value>
        -: 1429:struct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};
        -: 1430:
        -: 1431:template <class _Tp>
        -: 1432:struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point
        -: 1433:
        -: 1434:template <class _Tp, bool = is_arithmetic<_Tp>::value>
        -: 1435:struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};
        -: 1436:
        -: 1437:template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};
        -: 1438:
        -: 1439:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};
        -: 1440:
        -: 1441:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1442:template <class _Tp>
        -: 1443:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_signed_v
        -: 1444:    = is_signed<_Tp>::value;
        -: 1445:#endif
        -: 1446:
        -: 1447:#endif // __has_keyword(__is_signed)
        -: 1448:
        -: 1449:// is_unsigned
        -: 1450:
        -: 1451:#if __has_keyword(__is_unsigned)
        -: 1452:
        -: 1453:template<class _Tp>
        -: 1454:struct _LIBCPP_TEMPLATE_VIS is_unsigned : _BoolConstant<__is_unsigned(_Tp)> { };
        -: 1455:
        -: 1456:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1457:template <class _Tp>
        -: 1458:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_unsigned_v = __is_unsigned(_Tp);
        -: 1459:#endif
        -: 1460:
        -: 1461:#else // __has_keyword(__is_unsigned)
        -: 1462:
        -: 1463:template <class _Tp, bool = is_integral<_Tp>::value>
        -: 1464:struct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};
        -: 1465:
        -: 1466:template <class _Tp>
        -: 1467:struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point
        -: 1468:
        -: 1469:template <class _Tp, bool = is_arithmetic<_Tp>::value>
        -: 1470:struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};
        -: 1471:
        -: 1472:template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};
        -: 1473:
        -: 1474:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};
        -: 1475:
        -: 1476:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1477:template <class _Tp>
        -: 1478:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_unsigned_v
        -: 1479:    = is_unsigned<_Tp>::value;
        -: 1480:#endif
        -: 1481:
        -: 1482:#endif // __has_keyword(__is_unsigned)
        -: 1483:
        -: 1484:// rank
        -: 1485:
        -: 1486:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank
        -: 1487:    : public integral_constant<size_t, 0> {};
        -: 1488:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>
        -: 1489:    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
        -: 1490:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>
        -: 1491:    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
        -: 1492:
        -: 1493:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1494:template <class _Tp>
        -: 1495:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t rank_v
        -: 1496:    = rank<_Tp>::value;
        -: 1497:#endif
        -: 1498:
        -: 1499:// extent
        -: 1500:
        -: 1501:#if __has_keyword(__array_extent)
        -: 1502:
        -: 1503:template<class _Tp, size_t _Dim = 0>
        -: 1504:struct _LIBCPP_TEMPLATE_VIS extent
        -: 1505:    : integral_constant<size_t, __array_extent(_Tp, _Dim)> { };
        -: 1506:
        -: 1507:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1508:template <class _Tp, unsigned _Ip = 0>
        -: 1509:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t extent_v = __array_extent(_Tp, _Ip);
        -: 1510:#endif
        -: 1511:
        -: 1512:#else // __has_keyword(__array_extent)
        -: 1513:
        -: 1514:template <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent
        -: 1515:    : public integral_constant<size_t, 0> {};
        -: 1516:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>
        -: 1517:    : public integral_constant<size_t, 0> {};
        -: 1518:template <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>
        -: 1519:    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
        -: 1520:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>
        -: 1521:    : public integral_constant<size_t, _Np> {};
        -: 1522:template <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>
        -: 1523:    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
        -: 1524:
        -: 1525:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1526:template <class _Tp, unsigned _Ip = 0>
        -: 1527:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t extent_v
        -: 1528:    = extent<_Tp, _Ip>::value;
        -: 1529:#endif
        -: 1530:
        -: 1531:#endif // __has_keyword(__array_extent)
        -: 1532:
        -: 1533:// remove_extent
        -: 1534:
        -: 1535:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent
        -: 1536:    {typedef _Tp type;};
        -: 1537:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>
        -: 1538:    {typedef _Tp type;};
        -: 1539:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>
        -: 1540:    {typedef _Tp type;};
        -: 1541:
        -: 1542:#if _LIBCPP_STD_VER > 11
        -: 1543:template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
        -: 1544:#endif
        -: 1545:
        -: 1546:// remove_all_extents
        -: 1547:
        -: 1548:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents
        -: 1549:    {typedef _Tp type;};
        -: 1550:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>
        -: 1551:    {typedef typename remove_all_extents<_Tp>::type type;};
        -: 1552:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>
        -: 1553:    {typedef typename remove_all_extents<_Tp>::type type;};
        -: 1554:
        -: 1555:#if _LIBCPP_STD_VER > 11
        -: 1556:template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
        -: 1557:#endif
        -: 1558:
        -: 1559:#if _LIBCPP_STD_VER > 17
        -: 1560:// is_bounded_array
        -: 1561:
        -: 1562:template <class>                 struct _LIBCPP_TEMPLATE_VIS is_bounded_array           : false_type {};
        -: 1563:template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_bounded_array<_Tp[_Np]> : true_type {};
        -: 1564:
        -: 1565:template <class _Tp>
        -: 1566:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR
        -: 1567:bool is_bounded_array_v  = is_bounded_array<_Tp>::value;
        -: 1568:
        -: 1569:// is_unbounded_array
        -: 1570:
        -: 1571:template <class>     struct _LIBCPP_TEMPLATE_VIS is_unbounded_array        : false_type {};
        -: 1572:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unbounded_array<_Tp[]> : true_type {};
        -: 1573:
        -: 1574:template <class _Tp>
        -: 1575:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR
        -: 1576:bool is_unbounded_array_v  = is_unbounded_array<_Tp>::value;
        -: 1577:#endif
        -: 1578:
        -: 1579:// decay
        -: 1580:
        -: 1581:template <class _Up, bool>
        -: 1582:struct __decay {
        -: 1583:    typedef _LIBCPP_NODEBUG_TYPE typename remove_cv<_Up>::type type;
        -: 1584:};
        -: 1585:
        -: 1586:template <class _Up>
        -: 1587:struct __decay<_Up, true> {
        -: 1588:public:
        -: 1589:    typedef _LIBCPP_NODEBUG_TYPE typename conditional
        -: 1590:                     <
        -: 1591:                         is_array<_Up>::value,
        -: 1592:                         typename remove_extent<_Up>::type*,
        -: 1593:                         typename conditional
        -: 1594:                         <
        -: 1595:                              is_function<_Up>::value,
        -: 1596:                              typename add_pointer<_Up>::type,
        -: 1597:                              typename remove_cv<_Up>::type
        -: 1598:                         >::type
        -: 1599:                     >::type type;
        -: 1600:};
        -: 1601:
        -: 1602:template <class _Tp>
        -: 1603:struct _LIBCPP_TEMPLATE_VIS decay
        -: 1604:{
        -: 1605:private:
        -: 1606:    typedef _LIBCPP_NODEBUG_TYPE typename remove_reference<_Tp>::type _Up;
        -: 1607:public:
        -: 1608:    typedef _LIBCPP_NODEBUG_TYPE typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        -: 1609:};
        -: 1610:
        -: 1611:#if _LIBCPP_STD_VER > 11
        -: 1612:template <class _Tp> using decay_t = typename decay<_Tp>::type;
        -: 1613:#endif
        -: 1614:
        -: 1615:// is_abstract
        -: 1616:
        -: 1617:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract
        -: 1618:    : public integral_constant<bool, __is_abstract(_Tp)> {};
        -: 1619:
        -: 1620:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1621:template <class _Tp>
        -: 1622:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_abstract_v
        -: 1623:    = is_abstract<_Tp>::value;
        -: 1624:#endif
        -: 1625:
        -: 1626:// is_final
        -: 1627:
        -: 1628:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS
        -: 1629:__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
        -: 1630:
        -: 1631:#if _LIBCPP_STD_VER > 11
        -: 1632:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS
        -: 1633:is_final : public integral_constant<bool, __is_final(_Tp)> {};
        -: 1634:#endif
        -: 1635:
        -: 1636:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1637:template <class _Tp>
        -: 1638:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_final_v
        -: 1639:    = is_final<_Tp>::value;
        -: 1640:#endif
        -: 1641:
        -: 1642:// is_aggregate
        -: 1643:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)
        -: 1644:
        -: 1645:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS
        -: 1646:is_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};
        -: 1647:
        -: 1648:#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1649:template <class _Tp>
        -: 1650:_LIBCPP_INLINE_VAR constexpr bool is_aggregate_v
        -: 1651:    = is_aggregate<_Tp>::value;
        -: 1652:#endif
        -: 1653:
        -: 1654:#endif // _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)
        -: 1655:
        -: 1656:// is_base_of
        -: 1657:
        -: 1658:template <class _Bp, class _Dp>
        -: 1659:struct _LIBCPP_TEMPLATE_VIS is_base_of
        -: 1660:    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
        -: 1661:
        -: 1662:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1663:template <class _Bp, class _Dp>
        -: 1664:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_base_of_v
        -: 1665:    = is_base_of<_Bp, _Dp>::value;
        -: 1666:#endif
        -: 1667:
        -: 1668:// __is_core_convertible
        -: 1669:
        -: 1670:// [conv.general]/3 says "E is convertible to T" whenever "T t=E;" is well-formed.
        -: 1671:// We can't test for that, but we can test implicit convertibility by passing it
        -: 1672:// to a function. Notice that __is_core_convertible<void,void> is false,
        -: 1673:// and __is_core_convertible<immovable-type,immovable-type> is true in C++17 and later.
        -: 1674:
        -: 1675:template <class _Tp, class _Up, class = void>
        -: 1676:struct __is_core_convertible : public false_type {};
        -: 1677:
        -: 1678:template <class _Tp, class _Up>
        -: 1679:struct __is_core_convertible<_Tp, _Up, decltype(
        -: 1680:    static_cast<void(*)(_Up)>(0) ( static_cast<_Tp(*)()>(0)() )
        -: 1681:)> : public true_type {};
        -: 1682:
        -: 1683:// is_convertible
        -: 1684:
        -: 1685:#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)
        -: 1686:
        -: 1687:template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible
        -: 1688:    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};
        -: 1689:
        -: 1690:#else  // __has_feature(is_convertible_to)
        -: 1691:
        -: 1692:namespace __is_convertible_imp
        -: 1693:{
        -: 1694:template <class _Tp> void  __test_convert(_Tp);
        -: 1695:
        -: 1696:template <class _From, class _To, class = void>
        -: 1697:struct __is_convertible_test : public false_type {};
        -: 1698:
        -: 1699:template <class _From, class _To>
        -: 1700:struct __is_convertible_test<_From, _To,
        -: 1701:    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type
        -: 1702:{};
        -: 1703:
        -: 1704:template <class _Tp, bool _IsArray =    is_array<_Tp>::value,
        -: 1705:                     bool _IsFunction = is_function<_Tp>::value,
        -: 1706:                     bool _IsVoid =     is_void<_Tp>::value>
        -: 1707:                     struct __is_array_function_or_void                          {enum {value = 0};};
        -: 1708:template <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};
        -: 1709:template <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};
        -: 1710:template <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};
        -: 1711:}
        -: 1712:
        -: 1713:template <class _Tp,
        -: 1714:    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>
        -: 1715:struct __is_convertible_check
        -: 1716:{
        -: 1717:    static const size_t __v = 0;
        -: 1718:};
        -: 1719:
        -: 1720:template <class _Tp>
        -: 1721:struct __is_convertible_check<_Tp, 0>
        -: 1722:{
        -: 1723:    static const size_t __v = sizeof(_Tp);
        -: 1724:};
        -: 1725:
        -: 1726:template <class _T1, class _T2,
        -: 1727:    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
        -: 1728:    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
        -: 1729:struct __is_convertible
        -: 1730:    : public integral_constant<bool,
        -: 1731:        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value
        -: 1732:    >
        -: 1733:{};
        -: 1734:
        -: 1735:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};
        -: 1736:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};
        -: 1737:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};
        -: 1738:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};
        -: 1739:
        -: 1740:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};
        -: 1741:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};
        -: 1742:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};
        -: 1743:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};
        -: 1744:
        -: 1745:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};
        -: 1746:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};
        -: 1747:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};
        -: 1748:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};
        -: 1749:
        -: 1750:template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible
        -: 1751:    : public __is_convertible<_T1, _T2>
        -: 1752:{
        -: 1753:    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;
        -: 1754:    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;
        -: 1755:};
        -: 1756:
        -: 1757:#endif  // __has_feature(is_convertible_to)
        -: 1758:
        -: 1759:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1760:template <class _From, class _To>
        -: 1761:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_convertible_v
        -: 1762:    = is_convertible<_From, _To>::value;
        -: 1763:#endif
        -: 1764:
        -: 1765:// is_nothrow_convertible
        -: 1766:
        -: 1767:#if _LIBCPP_STD_VER > 17
        -: 1768:
        -: 1769:template <typename _Tp>
        -: 1770:static void __test_noexcept(_Tp) noexcept;
        -: 1771:
        -: 1772:template<typename _Fm, typename _To>
        -: 1773:static bool_constant<noexcept(_VSTD::__test_noexcept<_To>(declval<_Fm>()))>
        -: 1774:__is_nothrow_convertible_test();
        -: 1775:
        -: 1776:template <typename _Fm, typename _To>
        -: 1777:struct __is_nothrow_convertible_helper: decltype(__is_nothrow_convertible_test<_Fm, _To>())
        -: 1778:{ };
        -: 1779:
        -: 1780:template <typename _Fm, typename _To>
        -: 1781:struct is_nothrow_convertible : _Or<
        -: 1782:    _And<is_void<_To>, is_void<_Fm>>,
        -: 1783:    _Lazy<_And, is_convertible<_Fm, _To>, __is_nothrow_convertible_helper<_Fm, _To>>
        -: 1784:>::type { };
        -: 1785:
        -: 1786:template <typename _Fm, typename _To>
        -: 1787:inline constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<_Fm, _To>::value;
        -: 1788:
        -: 1789:#endif // _LIBCPP_STD_VER > 17
        -: 1790:
        -: 1791:// is_empty
        -: 1792:
        -: 1793:#if __has_feature(is_empty) || defined(_LIBCPP_COMPILER_GCC)
        -: 1794:
        -: 1795:template <class _Tp>
        -: 1796:struct _LIBCPP_TEMPLATE_VIS is_empty
        -: 1797:    : public integral_constant<bool, __is_empty(_Tp)> {};
        -: 1798:
        -: 1799:#else  // __has_feature(is_empty)
        -: 1800:
        -: 1801:template <class _Tp>
        -: 1802:struct __is_empty1
        -: 1803:    : public _Tp
        -: 1804:{
        -: 1805:    double __lx;
        -: 1806:};
        -: 1807:
        -: 1808:struct __is_empty2
        -: 1809:{
        -: 1810:    double __lx;
        -: 1811:};
        -: 1812:
        -: 1813:template <class _Tp, bool = is_class<_Tp>::value>
        -: 1814:struct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
        -: 1815:
        -: 1816:template <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};
        -: 1817:
        -: 1818:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};
        -: 1819:
        -: 1820:#endif  // __has_feature(is_empty)
        -: 1821:
        -: 1822:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1823:template <class _Tp>
        -: 1824:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_empty_v
        -: 1825:    = is_empty<_Tp>::value;
        -: 1826:#endif
        -: 1827:
        -: 1828:// is_polymorphic
        -: 1829:
        -: 1830:#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)
        -: 1831:
        -: 1832:template <class _Tp>
        -: 1833:struct _LIBCPP_TEMPLATE_VIS is_polymorphic
        -: 1834:    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
        -: 1835:
        -: 1836:#else
        -: 1837:
        -: 1838:template<typename _Tp> char &__is_polymorphic_impl(
        -: 1839:    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,
        -: 1840:                       int>::type);
        -: 1841:template<typename _Tp> __two &__is_polymorphic_impl(...);
        -: 1842:
        -: 1843:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic
        -: 1844:    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};
        -: 1845:
        -: 1846:#endif // __has_feature(is_polymorphic)
        -: 1847:
        -: 1848:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1849:template <class _Tp>
        -: 1850:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_polymorphic_v
        -: 1851:    = is_polymorphic<_Tp>::value;
        -: 1852:#endif
        -: 1853:
        -: 1854:// has_virtual_destructor
        -: 1855:
        -: 1856:#if __has_feature(has_virtual_destructor) || defined(_LIBCPP_COMPILER_GCC)
        -: 1857:
        -: 1858:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor
        -: 1859:    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
        -: 1860:
        -: 1861:#else
        -: 1862:
        -: 1863:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor
        -: 1864:    : public false_type {};
        -: 1865:
        -: 1866:#endif
        -: 1867:
        -: 1868:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1869:template <class _Tp>
        -: 1870:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool has_virtual_destructor_v
        -: 1871:    = has_virtual_destructor<_Tp>::value;
        -: 1872:#endif
        -: 1873:
        -: 1874:// has_unique_object_representations
        -: 1875:
        -: 1876:#if _LIBCPP_STD_VER > 14 && defined(_LIBCPP_HAS_UNIQUE_OBJECT_REPRESENTATIONS)
        -: 1877:
        -: 1878:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_unique_object_representations
        -: 1879:    : public integral_constant<bool,
        -: 1880:       __has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {};
        -: 1881:
        -: 1882:#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1883:template <class _Tp>
        -: 1884:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool has_unique_object_representations_v
        -: 1885:    = has_unique_object_representations<_Tp>::value;
        -: 1886:#endif
        -: 1887:
        -: 1888:#endif
        -: 1889:
        -: 1890:// alignment_of
        -: 1891:
        -: 1892:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of
        -: 1893:    : public integral_constant<size_t, _LIBCPP_ALIGNOF(_Tp)> {};
        -: 1894:
        -: 1895:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 1896:template <class _Tp>
        -: 1897:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t alignment_of_v
        -: 1898:    = alignment_of<_Tp>::value;
        -: 1899:#endif
        -: 1900:
        -: 1901:// aligned_storage
        -: 1902:
        -: 1903:template <class _Hp, class _Tp>
        -: 1904:struct __type_list
        -: 1905:{
        -: 1906:    typedef _Hp _Head;
        -: 1907:    typedef _Tp _Tail;
        -: 1908:};
        -: 1909:
        -: 1910:struct __nat
        -: 1911:{
        -: 1912:#ifndef _LIBCPP_CXX03_LANG
        -: 1913:    __nat() = delete;
        -: 1914:    __nat(const __nat&) = delete;
        -: 1915:    __nat& operator=(const __nat&) = delete;
        -: 1916:    ~__nat() = delete;
        -: 1917:#endif
        -: 1918:};
        -: 1919:
        -: 1920:template <class _Tp>
        -: 1921:struct __align_type
        -: 1922:{
        -: 1923:    static const size_t value = _LIBCPP_PREFERRED_ALIGNOF(_Tp);
        -: 1924:    typedef _Tp type;
        -: 1925:};
        -: 1926:
        -: 1927:struct __struct_double {long double __lx;};
        -: 1928:struct __struct_double4 {double __lx[4];};
        -: 1929:
        -: 1930:typedef
        -: 1931:    __type_list<__align_type<unsigned char>,
        -: 1932:    __type_list<__align_type<unsigned short>,
        -: 1933:    __type_list<__align_type<unsigned int>,
        -: 1934:    __type_list<__align_type<unsigned long>,
        -: 1935:    __type_list<__align_type<unsigned long long>,
        -: 1936:    __type_list<__align_type<double>,
        -: 1937:    __type_list<__align_type<long double>,
        -: 1938:    __type_list<__align_type<__struct_double>,
        -: 1939:    __type_list<__align_type<__struct_double4>,
        -: 1940:    __type_list<__align_type<int*>,
        -: 1941:    __nat
        -: 1942:    > > > > > > > > > > __all_types;
        -: 1943:
        -: 1944:template <size_t _Align>
        -: 1945:struct _ALIGNAS(_Align) __fallback_overaligned {};
        -: 1946:
        -: 1947:template <class _TL, size_t _Align> struct __find_pod;
        -: 1948:
        -: 1949:template <class _Hp, size_t _Align>
        -: 1950:struct __find_pod<__type_list<_Hp, __nat>, _Align>
        -: 1951:{
        -: 1952:    typedef typename conditional<
        -: 1953:                             _Align == _Hp::value,
        -: 1954:                             typename _Hp::type,
        -: 1955:                             __fallback_overaligned<_Align>
        -: 1956:                         >::type type;
        -: 1957:};
        -: 1958:
        -: 1959:template <class _Hp, class _Tp, size_t _Align>
        -: 1960:struct __find_pod<__type_list<_Hp, _Tp>, _Align>
        -: 1961:{
        -: 1962:    typedef typename conditional<
        -: 1963:                             _Align == _Hp::value,
        -: 1964:                             typename _Hp::type,
        -: 1965:                             typename __find_pod<_Tp, _Align>::type
        -: 1966:                         >::type type;
        -: 1967:};
        -: 1968:
        -: 1969:template <class _TL, size_t _Len> struct __find_max_align;
        -: 1970:
        -: 1971:template <class _Hp, size_t _Len>
        -: 1972:struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};
        -: 1973:
        -: 1974:template <size_t _Len, size_t _A1, size_t _A2>
        -: 1975:struct __select_align
        -: 1976:{
        -: 1977:private:
        -: 1978:    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
        -: 1979:    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
        -: 1980:public:
        -: 1981:    static const size_t value = _Len < __max ? __min : __max;
        -: 1982:};
        -: 1983:
        -: 1984:template <class _Hp, class _Tp, size_t _Len>
        -: 1985:struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
        -: 1986:    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};
        -: 1987:
        -: 1988:template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
        -: 1989:struct _LIBCPP_TEMPLATE_VIS aligned_storage
        -: 1990:{
        -: 1991:    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
        -: 1992:    union type
        -: 1993:    {
        -: 1994:        _Aligner __align;
        -: 1995:        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
        -: 1996:    };
        -: 1997:};
        -: 1998:
        -: 1999:#if _LIBCPP_STD_VER > 11
        -: 2000:template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
        -: 2001:    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
        -: 2002:#endif
        -: 2003:
        -: 2004:#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \
        -: 2005:template <size_t _Len>\
        -: 2006:struct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\
        -: 2007:{\
        -: 2008:    struct _ALIGNAS(n) type\
        -: 2009:    {\
        -: 2010:        unsigned char __lx[(_Len + n - 1)/n * n];\
        -: 2011:    };\
        -: 2012:}
        -: 2013:
        -: 2014:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);
        -: 2015:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);
        -: 2016:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);
        -: 2017:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);
        -: 2018:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);
        -: 2019:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);
        -: 2020:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);
        -: 2021:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);
        -: 2022:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);
        -: 2023:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);
        -: 2024:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);
        -: 2025:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);
        -: 2026:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);
        -: 2027:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);
        -: 2028:// PE/COFF does not support alignment beyond 8192 (=0x2000)
        -: 2029:#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)
        -: 2030:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);
        -: 2031:#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)
        -: 2032:
        -: 2033:#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION
        -: 2034:
        -: 2035:
        -: 2036:// aligned_union
        -: 2037:
        -: 2038:template <size_t _I0, size_t ..._In>
        -: 2039:struct __static_max;
        -: 2040:
        -: 2041:template <size_t _I0>
        -: 2042:struct __static_max<_I0>
        -: 2043:{
        -: 2044:    static const size_t value = _I0;
        -: 2045:};
        -: 2046:
        -: 2047:template <size_t _I0, size_t _I1, size_t ..._In>
        -: 2048:struct __static_max<_I0, _I1, _In...>
        -: 2049:{
        -: 2050:    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
        -: 2051:                                             __static_max<_I1, _In...>::value;
        -: 2052:};
        -: 2053:
        -: 2054:template <size_t _Len, class _Type0, class ..._Types>
        -: 2055:struct aligned_union
        -: 2056:{
        -: 2057:    static const size_t alignment_value = __static_max<_LIBCPP_PREFERRED_ALIGNOF(_Type0),
        -: 2058:                                                       _LIBCPP_PREFERRED_ALIGNOF(_Types)...>::value;
        -: 2059:    static const size_t __len = __static_max<_Len, sizeof(_Type0),
        -: 2060:                                             sizeof(_Types)...>::value;
        -: 2061:    typedef typename aligned_storage<__len, alignment_value>::type type;
        -: 2062:};
        -: 2063:
        -: 2064:#if _LIBCPP_STD_VER > 11
        -: 2065:template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
        -: 2066:#endif
        -: 2067:
        -: 2068:template <class _Tp>
        -: 2069:struct __numeric_type
        -: 2070:{
        -: 2071:   static void __test(...);
        -: 2072:   static float __test(float);
        -: 2073:   static double __test(char);
        -: 2074:   static double __test(int);
        -: 2075:   static double __test(unsigned);
        -: 2076:   static double __test(long);
        -: 2077:   static double __test(unsigned long);
        -: 2078:   static double __test(long long);
        -: 2079:   static double __test(unsigned long long);
        -: 2080:   static double __test(double);
        -: 2081:   static long double __test(long double);
        -: 2082:
        -: 2083:   typedef decltype(__test(declval<_Tp>())) type;
        -: 2084:   static const bool value = _IsNotSame<type, void>::value;
        -: 2085:};
        -: 2086:
        -: 2087:template <>
        -: 2088:struct __numeric_type<void>
        -: 2089:{
        -: 2090:   static const bool value = true;
        -: 2091:};
        -: 2092:
        -: 2093:// __promote
        -: 2094:
        -: 2095:template <class _A1, class _A2 = void, class _A3 = void,
        -: 2096:          bool = __numeric_type<_A1>::value &&
        -: 2097:                 __numeric_type<_A2>::value &&
        -: 2098:                 __numeric_type<_A3>::value>
        -: 2099:class __promote_imp
        -: 2100:{
        -: 2101:public:
        -: 2102:    static const bool value = false;
        -: 2103:};
        -: 2104:
        -: 2105:template <class _A1, class _A2, class _A3>
        -: 2106:class __promote_imp<_A1, _A2, _A3, true>
        -: 2107:{
        -: 2108:private:
        -: 2109:    typedef typename __promote_imp<_A1>::type __type1;
        -: 2110:    typedef typename __promote_imp<_A2>::type __type2;
        -: 2111:    typedef typename __promote_imp<_A3>::type __type3;
        -: 2112:public:
        -: 2113:    typedef decltype(__type1() + __type2() + __type3()) type;
        -: 2114:    static const bool value = true;
        -: 2115:};
        -: 2116:
        -: 2117:template <class _A1, class _A2>
        -: 2118:class __promote_imp<_A1, _A2, void, true>
        -: 2119:{
        -: 2120:private:
        -: 2121:    typedef typename __promote_imp<_A1>::type __type1;
        -: 2122:    typedef typename __promote_imp<_A2>::type __type2;
        -: 2123:public:
        -: 2124:    typedef decltype(__type1() + __type2()) type;
        -: 2125:    static const bool value = true;
        -: 2126:};
        -: 2127:
        -: 2128:template <class _A1>
        -: 2129:class __promote_imp<_A1, void, void, true>
        -: 2130:{
        -: 2131:public:
        -: 2132:    typedef typename __numeric_type<_A1>::type type;
        -: 2133:    static const bool value = true;
        -: 2134:};
        -: 2135:
        -: 2136:template <class _A1, class _A2 = void, class _A3 = void>
        -: 2137:class __promote : public __promote_imp<_A1, _A2, _A3> {};
        -: 2138:
        -: 2139:// make_signed / make_unsigned
        -: 2140:
        -: 2141:typedef
        -: 2142:    __type_list<signed char,
        -: 2143:    __type_list<signed short,
        -: 2144:    __type_list<signed int,
        -: 2145:    __type_list<signed long,
        -: 2146:    __type_list<signed long long,
        -: 2147:#ifndef _LIBCPP_HAS_NO_INT128
        -: 2148:    __type_list<__int128_t,
        -: 2149:#endif
        -: 2150:    __nat
        -: 2151:#ifndef _LIBCPP_HAS_NO_INT128
        -: 2152:    >
        -: 2153:#endif
        -: 2154:    > > > > > __signed_types;
        -: 2155:
        -: 2156:typedef
        -: 2157:    __type_list<unsigned char,
        -: 2158:    __type_list<unsigned short,
        -: 2159:    __type_list<unsigned int,
        -: 2160:    __type_list<unsigned long,
        -: 2161:    __type_list<unsigned long long,
        -: 2162:#ifndef _LIBCPP_HAS_NO_INT128
        -: 2163:    __type_list<__uint128_t,
        -: 2164:#endif
        -: 2165:    __nat
        -: 2166:#ifndef _LIBCPP_HAS_NO_INT128
        -: 2167:    >
        -: 2168:#endif
        -: 2169:    > > > > > __unsigned_types;
        -: 2170:
        -: 2171:template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
        -: 2172:
        -: 2173:template <class _Hp, class _Tp, size_t _Size>
        -: 2174:struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
        -: 2175:{
        -: 2176:    typedef _LIBCPP_NODEBUG_TYPE _Hp type;
        -: 2177:};
        -: 2178:
        -: 2179:template <class _Hp, class _Tp, size_t _Size>
        -: 2180:struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
        -: 2181:{
        -: 2182:    typedef _LIBCPP_NODEBUG_TYPE typename __find_first<_Tp, _Size>::type type;
        -: 2183:};
        -: 2184:
        -: 2185:template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
        -: 2186:                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
        -: 2187:struct __apply_cv
        -: 2188:{
        -: 2189:    typedef _LIBCPP_NODEBUG_TYPE _Up type;
        -: 2190:};
        -: 2191:
        -: 2192:template <class _Tp, class _Up>
        -: 2193:struct __apply_cv<_Tp, _Up, true, false>
        -: 2194:{
        -: 2195:    typedef _LIBCPP_NODEBUG_TYPE const _Up type;
        -: 2196:};
        -: 2197:
        -: 2198:template <class _Tp, class _Up>
        -: 2199:struct __apply_cv<_Tp, _Up, false, true>
        -: 2200:{
        -: 2201:    typedef volatile _Up type;
        -: 2202:};
        -: 2203:
        -: 2204:template <class _Tp, class _Up>
        -: 2205:struct __apply_cv<_Tp, _Up, true, true>
        -: 2206:{
        -: 2207:    typedef const volatile _Up type;
        -: 2208:};
        -: 2209:
        -: 2210:template <class _Tp, class _Up>
        -: 2211:struct __apply_cv<_Tp&, _Up, false, false>
        -: 2212:{
        -: 2213:    typedef _Up& type;
        -: 2214:};
        -: 2215:
        -: 2216:template <class _Tp, class _Up>
        -: 2217:struct __apply_cv<_Tp&, _Up, true, false>
        -: 2218:{
        -: 2219:    typedef const _Up& type;
        -: 2220:};
        -: 2221:
        -: 2222:template <class _Tp, class _Up>
        -: 2223:struct __apply_cv<_Tp&, _Up, false, true>
        -: 2224:{
        -: 2225:    typedef volatile _Up& type;
        -: 2226:};
        -: 2227:
        -: 2228:template <class _Tp, class _Up>
        -: 2229:struct __apply_cv<_Tp&, _Up, true, true>
        -: 2230:{
        -: 2231:    typedef const volatile _Up& type;
        -: 2232:};
        -: 2233:
        -: 2234:template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
        -: 2235:struct __make_signed {};
        -: 2236:
        -: 2237:template <class _Tp>
        -: 2238:struct __make_signed<_Tp, true>
        -: 2239:{
        -: 2240:    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
        -: 2241:};
        -: 2242:
        -: 2243:template <> struct __make_signed<bool,               true> {};
        -: 2244:template <> struct __make_signed<  signed short,     true> {typedef short     type;};
        -: 2245:template <> struct __make_signed<unsigned short,     true> {typedef short     type;};
        -: 2246:template <> struct __make_signed<  signed int,       true> {typedef int       type;};
        -: 2247:template <> struct __make_signed<unsigned int,       true> {typedef int       type;};
        -: 2248:template <> struct __make_signed<  signed long,      true> {typedef long      type;};
        -: 2249:template <> struct __make_signed<unsigned long,      true> {typedef long      type;};
        -: 2250:template <> struct __make_signed<  signed long long, true> {typedef long long type;};
        -: 2251:template <> struct __make_signed<unsigned long long, true> {typedef long long type;};
        -: 2252:#ifndef _LIBCPP_HAS_NO_INT128
        -: 2253:template <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};
        -: 2254:template <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};
        -: 2255:#endif
        -: 2256:
        -: 2257:template <class _Tp>
        -: 2258:struct _LIBCPP_TEMPLATE_VIS make_signed
        -: 2259:{
        -: 2260:    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
        -: 2261:};
        -: 2262:
        -: 2263:#if _LIBCPP_STD_VER > 11
        -: 2264:template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;
        -: 2265:#endif
        -: 2266:
        -: 2267:template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
        -: 2268:struct __make_unsigned {};
        -: 2269:
        -: 2270:template <class _Tp>
        -: 2271:struct __make_unsigned<_Tp, true>
        -: 2272:{
        -: 2273:    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
        -: 2274:};
        -: 2275:
        -: 2276:template <> struct __make_unsigned<bool,               true> {};
        -: 2277:template <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};
        -: 2278:template <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};
        -: 2279:template <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};
        -: 2280:template <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};
        -: 2281:template <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};
        -: 2282:template <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};
        -: 2283:template <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};
        -: 2284:template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};
        -: 2285:#ifndef _LIBCPP_HAS_NO_INT128
        -: 2286:template <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};
        -: 2287:template <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};
        -: 2288:#endif
        -: 2289:
        -: 2290:template <class _Tp>
        -: 2291:struct _LIBCPP_TEMPLATE_VIS make_unsigned
        -: 2292:{
        -: 2293:    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
        -: 2294:};
        -: 2295:
        -: 2296:#if _LIBCPP_STD_VER > 11
        -: 2297:template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
        -: 2298:#endif
        -: 2299:
        -: 2300:#if _LIBCPP_STD_VER > 14
        -: 2301:template <class...> using void_t = void;
        -: 2302:#endif
        -: 2303:
        -: 2304:#if _LIBCPP_STD_VER > 17
        -: 2305:// Let COND_RES(X, Y) be:
        -: 2306:template <class _Tp, class _Up>
        -: 2307:using __cond_type = decltype(false ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>());
        -: 2308:
        -: 2309:template <class _Tp, class _Up, class = void>
        -: 2310:struct __common_type3 {};
        -: 2311:
        -: 2312:// sub-bullet 4 - "if COND_RES(CREF(D1), CREF(D2)) denotes a type..."
        -: 2313:template <class _Tp, class _Up>
        -: 2314:struct __common_type3<_Tp, _Up, void_t<__cond_type<const _Tp&, const _Up&>>>
        -: 2315:{
        -: 2316:    using type = remove_cvref_t<__cond_type<const _Tp&, const _Up&>>;
        -: 2317:};
        -: 2318:
        -: 2319:template <class _Tp, class _Up, class = void>
        -: 2320:struct __common_type2_imp : __common_type3<_Tp, _Up> {};
        -: 2321:#else
        -: 2322:template <class _Tp, class _Up, class = void>
        -: 2323:struct __common_type2_imp {};
        -: 2324:#endif
        -: 2325:
        -: 2326:// sub-bullet 3 - "if decay_t<decltype(false ? declval<D1>() : declval<D2>())> ..."
        -: 2327:template <class _Tp, class _Up>
        -: 2328:struct __common_type2_imp<_Tp, _Up,
        -: 2329:                          typename __void_t<decltype(
        -: 2330:                                            true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
        -: 2331:                                            )>::type>
        -: 2332:{
        -: 2333:  typedef _LIBCPP_NODEBUG_TYPE typename decay<decltype(
        -: 2334:                         true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()
        -: 2335:                         )>::type type;
        -: 2336:};
        -: 2337:
        -: 2338:template <class, class = void>
        -: 2339:struct __common_type_impl {};
        -: 2340:
        -: 2341:// Clang provides variadic templates in C++03 as an extension.
        -: 2342:#if !defined(_LIBCPP_CXX03_LANG) || defined(__clang__)
        -: 2343:# define _LIBCPP_OPTIONAL_PACK(...) , __VA_ARGS__
        -: 2344:template <class... Tp>
        -: 2345:struct __common_types;
        -: 2346:template <class... _Tp>
        -: 2347:struct _LIBCPP_TEMPLATE_VIS common_type;
        -: 2348:#else
        -: 2349:# define _LIBCPP_OPTIONAL_PACK(...)
        -: 2350:struct __no_arg;
        -: 2351:template <class _Tp, class _Up, class = __no_arg>
        -: 2352:struct __common_types;
        -: 2353:template <class _Tp = __no_arg, class _Up = __no_arg, class _Vp = __no_arg,
        -: 2354:          class _Unused = __no_arg>
        -: 2355:struct common_type {
        -: 2356:  static_assert(sizeof(_Unused) == 0,
        -: 2357:                "common_type accepts at most 3 arguments in C++03");
        -: 2358:};
        -: 2359:#endif // _LIBCPP_CXX03_LANG
        -: 2360:
        -: 2361:template <class _Tp, class _Up>
        -: 2362:struct __common_type_impl<
        -: 2363:    __common_types<_Tp, _Up>,
        -: 2364:    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
        -: 2365:{
        -: 2366:  typedef typename common_type<_Tp, _Up>::type type;
        -: 2367:};
        -: 2368:
        -: 2369:template <class _Tp, class _Up, class _Vp _LIBCPP_OPTIONAL_PACK(class... _Rest)>
        -: 2370:struct __common_type_impl<
        -: 2371:    __common_types<_Tp, _Up, _Vp _LIBCPP_OPTIONAL_PACK(_Rest...)>,
        -: 2372:    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
        -: 2373:    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type,
        -: 2374:                                        _Vp _LIBCPP_OPTIONAL_PACK(_Rest...)> > {
        -: 2375:};
        -: 2376:
        -: 2377:// bullet 1 - sizeof...(Tp) == 0
        -: 2378:
        -: 2379:template <>
        -: 2380:struct _LIBCPP_TEMPLATE_VIS common_type<> {};
        -: 2381:
        -: 2382:// bullet 2 - sizeof...(Tp) == 1
        -: 2383:
        -: 2384:template <class _Tp>
        -: 2385:struct _LIBCPP_TEMPLATE_VIS common_type<_Tp>
        -: 2386:    : public common_type<_Tp, _Tp> {};
        -: 2387:
        -: 2388:// bullet 3 - sizeof...(Tp) == 2
        -: 2389:
        -: 2390:// sub-bullet 1 - "If is_same_v<T1, D1> is false or ..."
        -: 2391:template <class _Tp, class _Up>
        -: 2392:struct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>
        -: 2393:    : conditional<
        -: 2394:        _IsSame<_Tp, typename decay<_Tp>::type>::value && _IsSame<_Up, typename decay<_Up>::type>::value,
        -: 2395:        __common_type2_imp<_Tp, _Up>,
        -: 2396:        common_type<typename decay<_Tp>::type, typename decay<_Up>::type>
        -: 2397:    >::type
        -: 2398:{};
        -: 2399:
        -: 2400:// bullet 4 - sizeof...(Tp) > 2
        -: 2401:
        -: 2402:template <class _Tp, class _Up, class _Vp _LIBCPP_OPTIONAL_PACK(class... _Rest)>
        -: 2403:struct _LIBCPP_TEMPLATE_VIS
        -: 2404:    common_type<_Tp, _Up, _Vp _LIBCPP_OPTIONAL_PACK(_Rest...)>
        -: 2405:    : __common_type_impl<
        -: 2406:          __common_types<_Tp, _Up, _Vp _LIBCPP_OPTIONAL_PACK(_Rest...)> > {};
        -: 2407:
        -: 2408:#undef _LIBCPP_OPTIONAL_PACK
        -: 2409:
        -: 2410:#if _LIBCPP_STD_VER > 11
        -: 2411:template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
        -: 2412:#endif
        -: 2413:
        -: 2414:// is_assignable
        -: 2415:
        -: 2416:template<typename, typename _Tp> struct __select_2nd { typedef _LIBCPP_NODEBUG_TYPE _Tp type; };
        -: 2417:
        -: 2418:#if __has_keyword(__is_assignable)
        -: 2419:
        -: 2420:template<class _Tp, class _Up>
        -: 2421:struct _LIBCPP_TEMPLATE_VIS is_assignable : _BoolConstant<__is_assignable(_Tp, _Up)> { };
        -: 2422:
        -: 2423:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2424:template <class _Tp, class _Arg>
        -: 2425:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_assignable_v = __is_assignable(_Tp, _Arg);
        -: 2426:#endif
        -: 2427:
        -: 2428:#else // __has_keyword(__is_assignable)
        -: 2429:
        -: 2430:template <class _Tp, class _Arg>
        -: 2431:typename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type
        -: 2432:__is_assignable_test(int);
        -: 2433:
        -: 2434:template <class, class>
        -: 2435:false_type __is_assignable_test(...);
        -: 2436:
        -: 2437:
        -: 2438:template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
        -: 2439:struct __is_assignable_imp
        -: 2440:    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};
        -: 2441:
        -: 2442:template <class _Tp, class _Arg>
        -: 2443:struct __is_assignable_imp<_Tp, _Arg, true>
        -: 2444:    : public false_type
        -: 2445:{
        -: 2446:};
        -: 2447:
        -: 2448:template <class _Tp, class _Arg>
        -: 2449:struct is_assignable
        -: 2450:    : public __is_assignable_imp<_Tp, _Arg> {};
        -: 2451:
        -: 2452:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2453:template <class _Tp, class _Arg>
        -: 2454:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_assignable_v
        -: 2455:    = is_assignable<_Tp, _Arg>::value;
        -: 2456:#endif
        -: 2457:
        -: 2458:#endif  // __has_keyword(__is_assignable)
        -: 2459:
        -: 2460:// is_copy_assignable
        -: 2461:
        -: 2462:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable
        -: 2463:    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2464:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 2465:
        -: 2466:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2467:template <class _Tp>
        -: 2468:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_copy_assignable_v
        -: 2469:    = is_copy_assignable<_Tp>::value;
        -: 2470:#endif
        -: 2471:
        -: 2472:// is_move_assignable
        -: 2473:
        -: 2474:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable
        -: 2475:    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2476:                           typename add_rvalue_reference<_Tp>::type> {};
        -: 2477:
        -: 2478:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2479:template <class _Tp>
        -: 2480:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_move_assignable_v
        -: 2481:    = is_move_assignable<_Tp>::value;
        -: 2482:#endif
        -: 2483:
        -: 2484:// is_destructible
        -: 2485:
        -: 2486:#if __has_keyword(__is_destructible)
        -: 2487:
        -: 2488:template<class _Tp>
        -: 2489:struct _LIBCPP_TEMPLATE_VIS is_destructible : _BoolConstant<__is_destructible(_Tp)> { };
        -: 2490:
        -: 2491:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2492:template <class _Tp>
        -: 2493:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_destructible_v = __is_destructible(_Tp);
        -: 2494:#endif
        -: 2495:
        -: 2496:#else // __has_keyword(__is_destructible)
        -: 2497:
        -: 2498://  if it's a reference, return true
        -: 2499://  if it's a function, return false
        -: 2500://  if it's   void,     return false
        -: 2501://  if it's an array of unknown bound, return false
        -: 2502://  Otherwise, return "declval<_Up&>().~_Up()" is well-formed
        -: 2503://    where _Up is remove_all_extents<_Tp>::type
        -: 2504:
        -: 2505:template <class>
        -: 2506:struct __is_destructible_apply { typedef int type; };
        -: 2507:
        -: 2508:template <typename _Tp>
        -: 2509:struct __is_destructor_wellformed {
        -: 2510:    template <typename _Tp1>
        -: 2511:    static char  __test (
        -: 2512:        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type
        -: 2513:    );
        -: 2514:
        -: 2515:    template <typename _Tp1>
        -: 2516:    static __two __test (...);
        -: 2517:
        -: 2518:    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
        -: 2519:};
        -: 2520:
        -: 2521:template <class _Tp, bool>
        -: 2522:struct __destructible_imp;
        -: 2523:
        -: 2524:template <class _Tp>
        -: 2525:struct __destructible_imp<_Tp, false>
        -: 2526:   : public _VSTD::integral_constant<bool,
        -: 2527:        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};
        -: 2528:
        -: 2529:template <class _Tp>
        -: 2530:struct __destructible_imp<_Tp, true>
        -: 2531:    : public _VSTD::true_type {};
        -: 2532:
        -: 2533:template <class _Tp, bool>
        -: 2534:struct __destructible_false;
        -: 2535:
        -: 2536:template <class _Tp>
        -: 2537:struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};
        -: 2538:
        -: 2539:template <class _Tp>
        -: 2540:struct __destructible_false<_Tp, true> : public _VSTD::false_type {};
        -: 2541:
        -: 2542:template <class _Tp>
        -: 2543:struct is_destructible
        -: 2544:    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};
        -: 2545:
        -: 2546:template <class _Tp>
        -: 2547:struct is_destructible<_Tp[]>
        -: 2548:    : public _VSTD::false_type {};
        -: 2549:
        -: 2550:template <>
        -: 2551:struct is_destructible<void>
        -: 2552:    : public _VSTD::false_type {};
        -: 2553:
        -: 2554:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2555:template <class _Tp>
        -: 2556:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_destructible_v
        -: 2557:    = is_destructible<_Tp>::value;
        -: 2558:#endif
        -: 2559:
        -: 2560:#endif // __has_keyword(__is_destructible)
        -: 2561:
        -: 2562:// move
        -: 2563:
        -: 2564:template <class _Tp>
        -: 2565:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 2566:typename remove_reference<_Tp>::type&&
function _ZNSt3__1L4moveIRPFiP7__sFILEEEEONS_16remove_referenceIT_E4typeEOS7_ called 0 returned 0% blocks executed 0%
    #####: 2567:move(_Tp&& __t) _NOEXCEPT
        -: 2568:{
        -: 2569:    typedef _LIBCPP_NODEBUG_TYPE typename remove_reference<_Tp>::type _Up;
    #####: 2570:    return static_cast<_Up&&>(__t);
    $$$$$: 2570-block  0
        -: 2571:}
        -: 2572:
        -: 2573:template <class _Tp>
        -: 2574:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 2575:_Tp&&
function _ZNSt3__1L7forwardIRP7__sFILEEEOT_RNS_16remove_referenceIS4_E4typeE called 0 returned 0% blocks executed 0%
function _ZNSt3__1L7forwardIPFiP7__sFILEEEEOT_RNS_16remove_referenceIS5_E4typeE called 0 returned 0% blocks executed 0%
function _ZNSt3__1L7forwardINS_18__default_init_tagEEEOT_RNS_16remove_referenceIS2_E4typeE called 91 returned 100% blocks executed 100%
function _ZNSt3__1L7forwardIRKNS_9allocatorIcEEEEOT_RNS_16remove_referenceIS5_E4typeE called 2 returned 100% blocks executed 100%
function _ZNSt3__1L7forwardIPNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEOT_RNS_16remove_referenceIS8_E4typeE called 140 returned 100% blocks executed 100%
      233: 2576:forward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT
        -: 2577:{
      233: 2578:    return static_cast<_Tp&&>(__t);
    $$$$$: 2578-block  0
    $$$$$: 2578-block  1
       91: 2578-block  2
        2: 2578-block  3
      140: 2578-block  4
        -: 2579:}
        -: 2580:
        -: 2581:template <class _Tp>
        -: 2582:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 2583:_Tp&&
        -: 2584:forward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT
        -: 2585:{
        -: 2586:    static_assert(!is_lvalue_reference<_Tp>::value,
        -: 2587:                  "can not forward an rvalue as an lvalue");
        -: 2588:    return static_cast<_Tp&&>(__t);
        -: 2589:}
        -: 2590:
        -: 2591:template <class _Tp>
        -: 2592:inline _LIBCPP_INLINE_VISIBILITY
        -: 2593:typename decay<_Tp>::type
        -: 2594:__decay_copy(_Tp&& __t)
        -: 2595:{
        -: 2596:    return _VSTD::forward<_Tp>(__t);
        -: 2597:}
        -: 2598:
        -: 2599:template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
        -: 2600:struct __member_pointer_traits_imp
        -: 2601:{
        -: 2602:};
        -: 2603:
        -: 2604:template <class _Rp, class _Class, class ..._Param>
        -: 2605:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
        -: 2606:{
        -: 2607:    typedef _Class _ClassType;
        -: 2608:    typedef _Rp _ReturnType;
        -: 2609:    typedef _Rp (_FnType) (_Param...);
        -: 2610:};
        -: 2611:
        -: 2612:template <class _Rp, class _Class, class ..._Param>
        -: 2613:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
        -: 2614:{
        -: 2615:    typedef _Class _ClassType;
        -: 2616:    typedef _Rp _ReturnType;
        -: 2617:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2618:};
        -: 2619:
        -: 2620:template <class _Rp, class _Class, class ..._Param>
        -: 2621:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
        -: 2622:{
        -: 2623:    typedef _Class const _ClassType;
        -: 2624:    typedef _Rp _ReturnType;
        -: 2625:    typedef _Rp (_FnType) (_Param...);
        -: 2626:};
        -: 2627:
        -: 2628:template <class _Rp, class _Class, class ..._Param>
        -: 2629:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
        -: 2630:{
        -: 2631:    typedef _Class const _ClassType;
        -: 2632:    typedef _Rp _ReturnType;
        -: 2633:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2634:};
        -: 2635:
        -: 2636:template <class _Rp, class _Class, class ..._Param>
        -: 2637:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
        -: 2638:{
        -: 2639:    typedef _Class volatile _ClassType;
        -: 2640:    typedef _Rp _ReturnType;
        -: 2641:    typedef _Rp (_FnType) (_Param...);
        -: 2642:};
        -: 2643:
        -: 2644:template <class _Rp, class _Class, class ..._Param>
        -: 2645:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
        -: 2646:{
        -: 2647:    typedef _Class volatile _ClassType;
        -: 2648:    typedef _Rp _ReturnType;
        -: 2649:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2650:};
        -: 2651:
        -: 2652:template <class _Rp, class _Class, class ..._Param>
        -: 2653:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
        -: 2654:{
        -: 2655:    typedef _Class const volatile _ClassType;
        -: 2656:    typedef _Rp _ReturnType;
        -: 2657:    typedef _Rp (_FnType) (_Param...);
        -: 2658:};
        -: 2659:
        -: 2660:template <class _Rp, class _Class, class ..._Param>
        -: 2661:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
        -: 2662:{
        -: 2663:    typedef _Class const volatile _ClassType;
        -: 2664:    typedef _Rp _ReturnType;
        -: 2665:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2666:};
        -: 2667:
        -: 2668:#if __has_feature(cxx_reference_qualified_functions) || defined(_LIBCPP_COMPILER_GCC)
        -: 2669:
        -: 2670:template <class _Rp, class _Class, class ..._Param>
        -: 2671:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
        -: 2672:{
        -: 2673:    typedef _Class& _ClassType;
        -: 2674:    typedef _Rp _ReturnType;
        -: 2675:    typedef _Rp (_FnType) (_Param...);
        -: 2676:};
        -: 2677:
        -: 2678:template <class _Rp, class _Class, class ..._Param>
        -: 2679:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
        -: 2680:{
        -: 2681:    typedef _Class& _ClassType;
        -: 2682:    typedef _Rp _ReturnType;
        -: 2683:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2684:};
        -: 2685:
        -: 2686:template <class _Rp, class _Class, class ..._Param>
        -: 2687:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
        -: 2688:{
        -: 2689:    typedef _Class const& _ClassType;
        -: 2690:    typedef _Rp _ReturnType;
        -: 2691:    typedef _Rp (_FnType) (_Param...);
        -: 2692:};
        -: 2693:
        -: 2694:template <class _Rp, class _Class, class ..._Param>
        -: 2695:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
        -: 2696:{
        -: 2697:    typedef _Class const& _ClassType;
        -: 2698:    typedef _Rp _ReturnType;
        -: 2699:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2700:};
        -: 2701:
        -: 2702:template <class _Rp, class _Class, class ..._Param>
        -: 2703:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
        -: 2704:{
        -: 2705:    typedef _Class volatile& _ClassType;
        -: 2706:    typedef _Rp _ReturnType;
        -: 2707:    typedef _Rp (_FnType) (_Param...);
        -: 2708:};
        -: 2709:
        -: 2710:template <class _Rp, class _Class, class ..._Param>
        -: 2711:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
        -: 2712:{
        -: 2713:    typedef _Class volatile& _ClassType;
        -: 2714:    typedef _Rp _ReturnType;
        -: 2715:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2716:};
        -: 2717:
        -: 2718:template <class _Rp, class _Class, class ..._Param>
        -: 2719:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
        -: 2720:{
        -: 2721:    typedef _Class const volatile& _ClassType;
        -: 2722:    typedef _Rp _ReturnType;
        -: 2723:    typedef _Rp (_FnType) (_Param...);
        -: 2724:};
        -: 2725:
        -: 2726:template <class _Rp, class _Class, class ..._Param>
        -: 2727:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
        -: 2728:{
        -: 2729:    typedef _Class const volatile& _ClassType;
        -: 2730:    typedef _Rp _ReturnType;
        -: 2731:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2732:};
        -: 2733:
        -: 2734:template <class _Rp, class _Class, class ..._Param>
        -: 2735:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
        -: 2736:{
        -: 2737:    typedef _Class&& _ClassType;
        -: 2738:    typedef _Rp _ReturnType;
        -: 2739:    typedef _Rp (_FnType) (_Param...);
        -: 2740:};
        -: 2741:
        -: 2742:template <class _Rp, class _Class, class ..._Param>
        -: 2743:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
        -: 2744:{
        -: 2745:    typedef _Class&& _ClassType;
        -: 2746:    typedef _Rp _ReturnType;
        -: 2747:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2748:};
        -: 2749:
        -: 2750:template <class _Rp, class _Class, class ..._Param>
        -: 2751:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
        -: 2752:{
        -: 2753:    typedef _Class const&& _ClassType;
        -: 2754:    typedef _Rp _ReturnType;
        -: 2755:    typedef _Rp (_FnType) (_Param...);
        -: 2756:};
        -: 2757:
        -: 2758:template <class _Rp, class _Class, class ..._Param>
        -: 2759:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
        -: 2760:{
        -: 2761:    typedef _Class const&& _ClassType;
        -: 2762:    typedef _Rp _ReturnType;
        -: 2763:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2764:};
        -: 2765:
        -: 2766:template <class _Rp, class _Class, class ..._Param>
        -: 2767:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
        -: 2768:{
        -: 2769:    typedef _Class volatile&& _ClassType;
        -: 2770:    typedef _Rp _ReturnType;
        -: 2771:    typedef _Rp (_FnType) (_Param...);
        -: 2772:};
        -: 2773:
        -: 2774:template <class _Rp, class _Class, class ..._Param>
        -: 2775:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
        -: 2776:{
        -: 2777:    typedef _Class volatile&& _ClassType;
        -: 2778:    typedef _Rp _ReturnType;
        -: 2779:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2780:};
        -: 2781:
        -: 2782:template <class _Rp, class _Class, class ..._Param>
        -: 2783:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
        -: 2784:{
        -: 2785:    typedef _Class const volatile&& _ClassType;
        -: 2786:    typedef _Rp _ReturnType;
        -: 2787:    typedef _Rp (_FnType) (_Param...);
        -: 2788:};
        -: 2789:
        -: 2790:template <class _Rp, class _Class, class ..._Param>
        -: 2791:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
        -: 2792:{
        -: 2793:    typedef _Class const volatile&& _ClassType;
        -: 2794:    typedef _Rp _ReturnType;
        -: 2795:    typedef _Rp (_FnType) (_Param..., ...);
        -: 2796:};
        -: 2797:
        -: 2798:#endif  // __has_feature(cxx_reference_qualified_functions) || defined(_LIBCPP_COMPILER_GCC)
        -: 2799:
        -: 2800:
        -: 2801:template <class _Rp, class _Class>
        -: 2802:struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
        -: 2803:{
        -: 2804:    typedef _Class _ClassType;
        -: 2805:    typedef _Rp _ReturnType;
        -: 2806:};
        -: 2807:
        -: 2808:template <class _MP>
        -: 2809:struct __member_pointer_traits
        -: 2810:    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
        -: 2811:                    is_member_function_pointer<_MP>::value,
        -: 2812:                    is_member_object_pointer<_MP>::value>
        -: 2813:{
        -: 2814://     typedef ... _ClassType;
        -: 2815://     typedef ... _ReturnType;
        -: 2816://     typedef ... _FnType;
        -: 2817:};
        -: 2818:
        -: 2819:
        -: 2820:template <class _DecayedFp>
        -: 2821:struct __member_pointer_class_type {};
        -: 2822:
        -: 2823:template <class _Ret, class _ClassType>
        -: 2824:struct __member_pointer_class_type<_Ret _ClassType::*> {
        -: 2825:  typedef _ClassType type;
        -: 2826:};
        -: 2827:
        -: 2828:// template <class T, class... Args> struct is_constructible;
        -: 2829:
        -: 2830:#if defined(_LIBCPP_COMPILER_GCC) && _GNUC_VER_NEW >= 10000
        -: 2831:# define _LIBCPP_GCC_SUPPORTS_IS_CONSTRUCTIBLE
        -: 2832:#endif
        -: 2833:
        -: 2834:#if !defined(_LIBCPP_CXX03_LANG) && !__has_feature(is_constructible) && !defined(_LIBCPP_GCC_SUPPORTS_IS_CONSTRUCTIBLE)
        -: 2835:
        -: 2836:template <class _Tp, class... _Args>
        -: 2837:struct __libcpp_is_constructible;
        -: 2838:
        -: 2839:template <class _To, class _From>
        -: 2840:struct __is_invalid_base_to_derived_cast {
        -: 2841:  static_assert(is_reference<_To>::value, "Wrong specialization");
        -: 2842:  using _RawFrom = __uncvref_t<_From>;
        -: 2843:  using _RawTo = __uncvref_t<_To>;
        -: 2844:  static const bool value = _And<
        -: 2845:        _IsNotSame<_RawFrom, _RawTo>,
        -: 2846:        is_base_of<_RawFrom, _RawTo>,
        -: 2847:        _Not<__libcpp_is_constructible<_RawTo, _From>>
        -: 2848:  >::value;
        -: 2849:};
        -: 2850:
        -: 2851:template <class _To, class _From>
        -: 2852:struct __is_invalid_lvalue_to_rvalue_cast : false_type {
        -: 2853:  static_assert(is_reference<_To>::value, "Wrong specialization");
        -: 2854:};
        -: 2855:
        -: 2856:template <class _ToRef, class _FromRef>
        -: 2857:struct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {
        -: 2858:  using _RawFrom = __uncvref_t<_FromRef>;
        -: 2859:  using _RawTo = __uncvref_t<_ToRef>;
        -: 2860:  static const bool value = _And<
        -: 2861:      _Not<is_function<_RawTo>>,
        -: 2862:      _Or<
        -: 2863:        _IsSame<_RawFrom, _RawTo>,
        -: 2864:        is_base_of<_RawTo, _RawFrom>>
        -: 2865:    >::value;
        -: 2866:};
        -: 2867:
        -: 2868:struct __is_constructible_helper
        -: 2869:{
        -: 2870:    template <class _To>
        -: 2871:    static void __eat(_To);
        -: 2872:
        -: 2873:    // This overload is needed to work around a Clang bug that disallows
        -: 2874:    // static_cast<T&&>(e) for non-reference-compatible types.
        -: 2875:    // Example: static_cast<int&&>(declval<double>());
        -: 2876:    // NOTE: The static_cast implementation below is required to support
        -: 2877:    //  classes with explicit conversion operators.
        -: 2878:    template <class _To, class _From,
        -: 2879:              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>
        -: 2880:    static true_type __test_cast(int);
        -: 2881:
        -: 2882:    template <class _To, class _From,
        -: 2883:              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>
        -: 2884:    static integral_constant<bool,
        -: 2885:        !__is_invalid_base_to_derived_cast<_To, _From>::value &&
        -: 2886:        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value
        -: 2887:    > __test_cast(long);
        -: 2888:
        -: 2889:    template <class, class>
        -: 2890:    static false_type __test_cast(...);
        -: 2891:
        -: 2892:    template <class _Tp, class ..._Args,
        -: 2893:        class = decltype(_Tp(_VSTD::declval<_Args>()...))>
        -: 2894:    static true_type __test_nary(int);
        -: 2895:    template <class _Tp, class...>
        -: 2896:    static false_type __test_nary(...);
        -: 2897:
        -: 2898:    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>
        -: 2899:    static is_destructible<_Tp> __test_unary(int);
        -: 2900:    template <class, class>
        -: 2901:    static false_type __test_unary(...);
        -: 2902:};
        -: 2903:
        -: 2904:template <class _Tp, bool = is_void<_Tp>::value>
        -: 2905:struct __is_default_constructible
        -: 2906:    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))
        -: 2907:{};
        -: 2908:
        -: 2909:template <class _Tp>
        -: 2910:struct __is_default_constructible<_Tp, true> : false_type {};
        -: 2911:
        -: 2912:template <class _Tp>
        -: 2913:struct __is_default_constructible<_Tp[], false> : false_type {};
        -: 2914:
        -: 2915:template <class _Tp, size_t _Nx>
        -: 2916:struct __is_default_constructible<_Tp[_Nx], false>
        -: 2917:    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};
        -: 2918:
        -: 2919:template <class _Tp, class... _Args>
        -: 2920:struct __libcpp_is_constructible
        -: 2921:{
        -: 2922:  static_assert(sizeof...(_Args) > 1, "Wrong specialization");
        -: 2923:  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))
        -: 2924:      type;
        -: 2925:};
        -: 2926:
        -: 2927:template <class _Tp>
        -: 2928:struct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};
        -: 2929:
        -: 2930:template <class _Tp, class _A0>
        -: 2931:struct __libcpp_is_constructible<_Tp, _A0>
        -: 2932:    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))
        -: 2933:{};
        -: 2934:
        -: 2935:template <class _Tp, class _A0>
        -: 2936:struct __libcpp_is_constructible<_Tp&, _A0>
        -: 2937:    : public decltype(__is_constructible_helper::
        -: 2938:    __test_cast<_Tp&, _A0>(0))
        -: 2939:{};
        -: 2940:
        -: 2941:template <class _Tp, class _A0>
        -: 2942:struct __libcpp_is_constructible<_Tp&&, _A0>
        -: 2943:    : public decltype(__is_constructible_helper::
        -: 2944:    __test_cast<_Tp&&, _A0>(0))
        -: 2945:{};
        -: 2946:
        -: 2947:#endif
        -: 2948:
        -: 2949:#if __has_feature(is_constructible) || defined(_LIBCPP_GCC_SUPPORTS_IS_CONSTRUCTIBLE)
        -: 2950:template <class _Tp, class ..._Args>
        -: 2951:struct _LIBCPP_TEMPLATE_VIS is_constructible
        -: 2952:    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
        -: 2953:    {};
        -: 2954:#else
        -: 2955:template <class _Tp, class... _Args>
        -: 2956:struct _LIBCPP_TEMPLATE_VIS is_constructible
        -: 2957:    : public __libcpp_is_constructible<_Tp, _Args...>::type {};
        -: 2958:#endif
        -: 2959:
        -: 2960:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2961:template <class _Tp, class ..._Args>
        -: 2962:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_constructible_v
        -: 2963:    = is_constructible<_Tp, _Args...>::value;
        -: 2964:#endif
        -: 2965:
        -: 2966:// is_default_constructible
        -: 2967:
        -: 2968:template <class _Tp>
        -: 2969:struct _LIBCPP_TEMPLATE_VIS is_default_constructible
        -: 2970:    : public is_constructible<_Tp>
        -: 2971:    {};
        -: 2972:
        -: 2973:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 2974:template <class _Tp>
        -: 2975:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_default_constructible_v
        -: 2976:    = is_default_constructible<_Tp>::value;
        -: 2977:#endif
        -: 2978:
        -: 2979:#ifndef _LIBCPP_CXX03_LANG
        -: 2980:// First of all, we can't implement this check in C++03 mode because the {}
        -: 2981:// default initialization syntax isn't valid.
        -: 2982:// Second, we implement the trait in a funny manner with two defaulted template
        -: 2983:// arguments to workaround Clang's PR43454.
        -: 2984:template <class _Tp>
        -: 2985:void __test_implicit_default_constructible(_Tp);
        -: 2986:
        -: 2987:template <class _Tp, class = void, bool = is_default_constructible<_Tp>::value>
        -: 2988:struct __is_implicitly_default_constructible
        -: 2989:    : false_type
        -: 2990:{ };
        -: 2991:
        -: 2992:template <class _Tp>
        -: 2993:struct __is_implicitly_default_constructible<_Tp, decltype(__test_implicit_default_constructible<_Tp const&>({})), true>
        -: 2994:    : true_type
        -: 2995:{ };
        -: 2996:
        -: 2997:template <class _Tp>
        -: 2998:struct __is_implicitly_default_constructible<_Tp, decltype(__test_implicit_default_constructible<_Tp const&>({})), false>
        -: 2999:    : false_type
        -: 3000:{ };
        -: 3001:#endif // !C++03
        -: 3002:
        -: 3003:// is_copy_constructible
        -: 3004:
        -: 3005:template <class _Tp>
        -: 3006:struct _LIBCPP_TEMPLATE_VIS is_copy_constructible
        -: 3007:    : public is_constructible<_Tp,
        -: 3008:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3009:
        -: 3010:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3011:template <class _Tp>
        -: 3012:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_copy_constructible_v
        -: 3013:    = is_copy_constructible<_Tp>::value;
        -: 3014:#endif
        -: 3015:
        -: 3016:// is_move_constructible
        -: 3017:
        -: 3018:template <class _Tp>
        -: 3019:struct _LIBCPP_TEMPLATE_VIS is_move_constructible
        -: 3020:    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 3021:    {};
        -: 3022:
        -: 3023:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3024:template <class _Tp>
        -: 3025:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_move_constructible_v
        -: 3026:    = is_move_constructible<_Tp>::value;
        -: 3027:#endif
        -: 3028:
        -: 3029:// is_trivially_constructible
        -: 3030:
        -: 3031:#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
        -: 3032:
        -: 3033:template <class _Tp, class... _Args>
        -: 3034:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
        -: 3035:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
        -: 3036:{
        -: 3037:};
        -: 3038:
        -: 3039:#else  // !__has_feature(is_trivially_constructible)
        -: 3040:
        -: 3041:template <class _Tp, class... _Args>
        -: 3042:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible
        -: 3043:    : false_type
        -: 3044:{
        -: 3045:};
        -: 3046:
        -: 3047:template <class _Tp>
        -: 3048:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>
        -: 3049:#if __has_feature(has_trivial_constructor) || defined(_LIBCPP_COMPILER_GCC)
        -: 3050:    : integral_constant<bool, __has_trivial_constructor(_Tp)>
        -: 3051:#else
        -: 3052:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3053:#endif
        -: 3054:{
        -: 3055:};
        -: 3056:
        -: 3057:template <class _Tp>
        -: 3058:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>
        -: 3059:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3060:{
        -: 3061:};
        -: 3062:
        -: 3063:template <class _Tp>
        -: 3064:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>
        -: 3065:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3066:{
        -: 3067:};
        -: 3068:
        -: 3069:template <class _Tp>
        -: 3070:struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>
        -: 3071:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 3072:{
        -: 3073:};
        -: 3074:
        -: 3075:#endif  // !__has_feature(is_trivially_constructible)
        -: 3076:
        -: 3077:
        -: 3078:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3079:template <class _Tp, class... _Args>
        -: 3080:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_constructible_v
        -: 3081:    = is_trivially_constructible<_Tp, _Args...>::value;
        -: 3082:#endif
        -: 3083:
        -: 3084:// is_trivially_default_constructible
        -: 3085:
        -: 3086:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible
        -: 3087:    : public is_trivially_constructible<_Tp>
        -: 3088:    {};
        -: 3089:
        -: 3090:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3091:template <class _Tp>
        -: 3092:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v
        -: 3093:    = is_trivially_default_constructible<_Tp>::value;
        -: 3094:#endif
        -: 3095:
        -: 3096:// is_trivially_copy_constructible
        -: 3097:
        -: 3098:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible
        -: 3099:    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
        -: 3100:    {};
        -: 3101:
        -: 3102:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3103:template <class _Tp>
        -: 3104:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v
        -: 3105:    = is_trivially_copy_constructible<_Tp>::value;
        -: 3106:#endif
        -: 3107:
        -: 3108:// is_trivially_move_constructible
        -: 3109:
        -: 3110:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible
        -: 3111:    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 3112:    {};
        -: 3113:
        -: 3114:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3115:template <class _Tp>
        -: 3116:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v
        -: 3117:    = is_trivially_move_constructible<_Tp>::value;
        -: 3118:#endif
        -: 3119:
        -: 3120:// is_trivially_assignable
        -: 3121:
        -: 3122:#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501
        -: 3123:
        -: 3124:template <class _Tp, class _Arg>
        -: 3125:struct is_trivially_assignable
        -: 3126:    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
        -: 3127:{
        -: 3128:};
        -: 3129:
        -: 3130:#else  // !__has_feature(is_trivially_assignable)
        -: 3131:
        -: 3132:template <class _Tp, class _Arg>
        -: 3133:struct is_trivially_assignable
        -: 3134:    : public false_type {};
        -: 3135:
        -: 3136:template <class _Tp>
        -: 3137:struct is_trivially_assignable<_Tp&, _Tp>
        -: 3138:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3139:
        -: 3140:template <class _Tp>
        -: 3141:struct is_trivially_assignable<_Tp&, _Tp&>
        -: 3142:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3143:
        -: 3144:template <class _Tp>
        -: 3145:struct is_trivially_assignable<_Tp&, const _Tp&>
        -: 3146:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3147:
        -: 3148:template <class _Tp>
        -: 3149:struct is_trivially_assignable<_Tp&, _Tp&&>
        -: 3150:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 3151:
        -: 3152:#endif  // !__has_feature(is_trivially_assignable)
        -: 3153:
        -: 3154:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3155:template <class _Tp, class _Arg>
        -: 3156:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_assignable_v
        -: 3157:    = is_trivially_assignable<_Tp, _Arg>::value;
        -: 3158:#endif
        -: 3159:
        -: 3160:// is_trivially_copy_assignable
        -: 3161:
        -: 3162:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable
        -: 3163:    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 3164:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3165:
        -: 3166:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3167:template <class _Tp>
        -: 3168:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v
        -: 3169:    = is_trivially_copy_assignable<_Tp>::value;
        -: 3170:#endif
        -: 3171:
        -: 3172:// is_trivially_move_assignable
        -: 3173:
        -: 3174:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable
        -: 3175:    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 3176:                                     typename add_rvalue_reference<_Tp>::type>
        -: 3177:    {};
        -: 3178:
        -: 3179:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3180:template <class _Tp>
        -: 3181:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v
        -: 3182:    = is_trivially_move_assignable<_Tp>::value;
        -: 3183:#endif
        -: 3184:
        -: 3185:// is_trivially_destructible
        -: 3186:
        -: 3187:#if __has_keyword(__is_trivially_destructible)
        -: 3188:
        -: 3189:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible
        -: 3190:    : public integral_constant<bool, __is_trivially_destructible(_Tp)> {};
        -: 3191:
        -: 3192:#elif __has_feature(has_trivial_destructor) || defined(_LIBCPP_COMPILER_GCC)
        -: 3193:
        -: 3194:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible
        -: 3195:    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};
        -: 3196:
        -: 3197:#else
        -: 3198:
        -: 3199:template <class _Tp> struct __libcpp_trivial_destructor
        -: 3200:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 3201:                                     is_reference<_Tp>::value> {};
        -: 3202:
        -: 3203:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible
        -: 3204:    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};
        -: 3205:
        -: 3206:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>
        -: 3207:    : public false_type {};
        -: 3208:
        -: 3209:#endif
        -: 3210:
        -: 3211:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3212:template <class _Tp>
        -: 3213:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_destructible_v
        -: 3214:    = is_trivially_destructible<_Tp>::value;
        -: 3215:#endif
        -: 3216:
        -: 3217:// is_nothrow_constructible
        -: 3218:
        -: 3219:#if __has_keyword(__is_nothrow_constructible)
        -: 3220:
        -: 3221:template <class _Tp, class... _Args>
        -: 3222:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
        -: 3223:    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {};
        -: 3224:
        -: 3225:#else
        -: 3226:
        -: 3227:template <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;
        -: 3228:
        -: 3229:template <class _Tp, class... _Args>
        -: 3230:struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>
        -: 3231:    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
        -: 3232:{
        -: 3233:};
        -: 3234:
        -: 3235:template <class _Tp>
        -: 3236:void __implicit_conversion_to(_Tp) noexcept { }
        -: 3237:
        -: 3238:template <class _Tp, class _Arg>
        -: 3239:struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>
        -: 3240:    : public integral_constant<bool, noexcept(_VSTD::__implicit_conversion_to<_Tp>(declval<_Arg>()))>
        -: 3241:{
        -: 3242:};
        -: 3243:
        -: 3244:template <class _Tp, bool _IsReference, class... _Args>
        -: 3245:struct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>
        -: 3246:    : public false_type
        -: 3247:{
        -: 3248:};
        -: 3249:
        -: 3250:template <class _Tp, class... _Args>
        -: 3251:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible
        -: 3252:    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>
        -: 3253:{
        -: 3254:};
        -: 3255:
        -: 3256:template <class _Tp, size_t _Ns>
        -: 3257:struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>
        -: 3258:    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>
        -: 3259:{
        -: 3260:};
        -: 3261:
        -: 3262:#endif  // _LIBCPP_HAS_NO_NOEXCEPT
        -: 3263:
        -: 3264:
        -: 3265:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3266:template <class _Tp, class ..._Args>
        -: 3267:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v
        -: 3268:    = is_nothrow_constructible<_Tp, _Args...>::value;
        -: 3269:#endif
        -: 3270:
        -: 3271:// is_nothrow_default_constructible
        -: 3272:
        -: 3273:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible
        -: 3274:    : public is_nothrow_constructible<_Tp>
        -: 3275:    {};
        -: 3276:
        -: 3277:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3278:template <class _Tp>
        -: 3279:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v
        -: 3280:    = is_nothrow_default_constructible<_Tp>::value;
        -: 3281:#endif
        -: 3282:
        -: 3283:// is_nothrow_copy_constructible
        -: 3284:
        -: 3285:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible
        -: 3286:    : public is_nothrow_constructible<_Tp,
        -: 3287:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3288:
        -: 3289:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3290:template <class _Tp>
        -: 3291:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v
        -: 3292:    = is_nothrow_copy_constructible<_Tp>::value;
        -: 3293:#endif
        -: 3294:
        -: 3295:// is_nothrow_move_constructible
        -: 3296:
        -: 3297:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible
        -: 3298:    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 3299:    {};
        -: 3300:
        -: 3301:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3302:template <class _Tp>
        -: 3303:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v
        -: 3304:    = is_nothrow_move_constructible<_Tp>::value;
        -: 3305:#endif
        -: 3306:
        -: 3307:// is_nothrow_assignable
        -: 3308:
        -: 3309:#if __has_keyword(__is_nothrow_assignable)
        -: 3310:
        -: 3311:template <class _Tp, class _Arg>
        -: 3312:struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable
        -: 3313:    : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {};
        -: 3314:
        -: 3315:#else
        -: 3316:
        -: 3317:template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;
        -: 3318:
        -: 3319:template <class _Tp, class _Arg>
        -: 3320:struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
        -: 3321:    : public false_type
        -: 3322:{
        -: 3323:};
        -: 3324:
        -: 3325:template <class _Tp, class _Arg>
        -: 3326:struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
        -: 3327:    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >
        -: 3328:{
        -: 3329:};
        -: 3330:
        -: 3331:template <class _Tp, class _Arg>
        -: 3332:struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable
        -: 3333:    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
        -: 3334:{
        -: 3335:};
        -: 3336:
        -: 3337:#endif  // _LIBCPP_HAS_NO_NOEXCEPT
        -: 3338:
        -: 3339:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3340:template <class _Tp, class _Arg>
        -: 3341:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v
        -: 3342:    = is_nothrow_assignable<_Tp, _Arg>::value;
        -: 3343:#endif
        -: 3344:
        -: 3345:// is_nothrow_copy_assignable
        -: 3346:
        -: 3347:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable
        -: 3348:    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 3349:                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
        -: 3350:
        -: 3351:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3352:template <class _Tp>
        -: 3353:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v
        -: 3354:    = is_nothrow_copy_assignable<_Tp>::value;
        -: 3355:#endif
        -: 3356:
        -: 3357:// is_nothrow_move_assignable
        -: 3358:
        -: 3359:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable
        -: 3360:    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 3361:                                     typename add_rvalue_reference<_Tp>::type>
        -: 3362:    {};
        -: 3363:
        -: 3364:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3365:template <class _Tp>
        -: 3366:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v
        -: 3367:    = is_nothrow_move_assignable<_Tp>::value;
        -: 3368:#endif
        -: 3369:
        -: 3370:// is_nothrow_destructible
        -: 3371:
        -: 3372:#if !defined(_LIBCPP_CXX03_LANG)
        -: 3373:
        -: 3374:template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;
        -: 3375:
        -: 3376:template <class _Tp>
        -: 3377:struct __libcpp_is_nothrow_destructible<false, _Tp>
        -: 3378:    : public false_type
        -: 3379:{
        -: 3380:};
        -: 3381:
        -: 3382:template <class _Tp>
        -: 3383:struct __libcpp_is_nothrow_destructible<true, _Tp>
        -: 3384:    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >
        -: 3385:{
        -: 3386:};
        -: 3387:
        -: 3388:template <class _Tp>
        -: 3389:struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible
        -: 3390:    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
        -: 3391:{
        -: 3392:};
        -: 3393:
        -: 3394:template <class _Tp, size_t _Ns>
        -: 3395:struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>
        -: 3396:    : public is_nothrow_destructible<_Tp>
        -: 3397:{
        -: 3398:};
        -: 3399:
        -: 3400:template <class _Tp>
        -: 3401:struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>
        -: 3402:    : public true_type
        -: 3403:{
        -: 3404:};
        -: 3405:
        -: 3406:template <class _Tp>
        -: 3407:struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>
        -: 3408:    : public true_type
        -: 3409:{
        -: 3410:};
        -: 3411:
        -: 3412:#else
        -: 3413:
        -: 3414:template <class _Tp> struct __libcpp_nothrow_destructor
        -: 3415:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 3416:                                     is_reference<_Tp>::value> {};
        -: 3417:
        -: 3418:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible
        -: 3419:    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};
        -: 3420:
        -: 3421:template <class _Tp>
        -: 3422:struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>
        -: 3423:    : public false_type {};
        -: 3424:
        -: 3425:#endif
        -: 3426:
        -: 3427:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3428:template <class _Tp>
        -: 3429:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v
        -: 3430:    = is_nothrow_destructible<_Tp>::value;
        -: 3431:#endif
        -: 3432:
        -: 3433:// is_pod
        -: 3434:
        -: 3435:#if __has_feature(is_pod) || defined(_LIBCPP_COMPILER_GCC)
        -: 3436:
        -: 3437:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod
        -: 3438:    : public integral_constant<bool, __is_pod(_Tp)> {};
        -: 3439:
        -: 3440:#else
        -: 3441:
        -: 3442:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod
        -: 3443:    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&
        -: 3444:                                     is_trivially_copy_constructible<_Tp>::value      &&
        -: 3445:                                     is_trivially_copy_assignable<_Tp>::value    &&
        -: 3446:                                     is_trivially_destructible<_Tp>::value> {};
        -: 3447:
        -: 3448:#endif
        -: 3449:
        -: 3450:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3451:template <class _Tp>
        -: 3452:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pod_v
        -: 3453:    = is_pod<_Tp>::value;
        -: 3454:#endif
        -: 3455:
        -: 3456:// is_literal_type;
        -: 3457:
        -: 3458:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type
        -: 3459:    : public integral_constant<bool, __is_literal_type(_Tp)>
        -: 3460:    {};
        -: 3461:
        -: 3462:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3463:template <class _Tp>
        -: 3464:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_literal_type_v
        -: 3465:    = is_literal_type<_Tp>::value;
        -: 3466:#endif
        -: 3467:
        -: 3468:// is_standard_layout;
        -: 3469:
        -: 3470:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout
        -: 3471:#if __has_feature(is_standard_layout) || defined(_LIBCPP_COMPILER_GCC)
        -: 3472:    : public integral_constant<bool, __is_standard_layout(_Tp)>
        -: 3473:#else
        -: 3474:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
        -: 3475:#endif
        -: 3476:    {};
        -: 3477:
        -: 3478:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3479:template <class _Tp>
        -: 3480:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_standard_layout_v
        -: 3481:    = is_standard_layout<_Tp>::value;
        -: 3482:#endif
        -: 3483:
        -: 3484:// is_trivially_copyable;
        -: 3485:
        -: 3486:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable
        -: 3487:#if __has_feature(is_trivially_copyable)
        -: 3488:    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
        -: 3489:#elif _GNUC_VER >= 501
        -: 3490:    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>
        -: 3491:#else
        -: 3492:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
        -: 3493:#endif
        -: 3494:    {};
        -: 3495:
        -: 3496:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3497:template <class _Tp>
        -: 3498:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copyable_v
        -: 3499:    = is_trivially_copyable<_Tp>::value;
        -: 3500:#endif
        -: 3501:
        -: 3502:// is_trivial;
        -: 3503:
        -: 3504:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial
        -: 3505:#if __has_feature(is_trivial) || defined(_LIBCPP_COMPILER_GCC)
        -: 3506:    : public integral_constant<bool, __is_trivial(_Tp)>
        -: 3507:#else
        -: 3508:    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&
        -: 3509:                                 is_trivially_default_constructible<_Tp>::value>
        -: 3510:#endif
        -: 3511:    {};
        -: 3512:
        -: 3513:#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
        -: 3514:template <class _Tp>
        -: 3515:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivial_v
        -: 3516:    = is_trivial<_Tp>::value;
        -: 3517:#endif
        -: 3518:
        -: 3519:template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
        -: 3520:template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
        -: 3521:template <class _Tp> struct __is_reference_wrapper
        -: 3522:    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};
        -: 3523:
        -: 3524:#ifndef _LIBCPP_CXX03_LANG
        -: 3525:
        -: 3526:template <class _Fp, class _A0,
        -: 3527:         class _DecayFp = typename decay<_Fp>::type,
        -: 3528:         class _DecayA0 = typename decay<_A0>::type,
        -: 3529:         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
        -: 3530:using __enable_if_bullet1 = typename enable_if
        -: 3531:    <
        -: 3532:        is_member_function_pointer<_DecayFp>::value
        -: 3533:        && is_base_of<_ClassT, _DecayA0>::value
        -: 3534:    >::type;
        -: 3535:
        -: 3536:template <class _Fp, class _A0,
        -: 3537:         class _DecayFp = typename decay<_Fp>::type,
        -: 3538:         class _DecayA0 = typename decay<_A0>::type>
        -: 3539:using __enable_if_bullet2 = typename enable_if
        -: 3540:    <
        -: 3541:        is_member_function_pointer<_DecayFp>::value
        -: 3542:        && __is_reference_wrapper<_DecayA0>::value
        -: 3543:    >::type;
        -: 3544:
        -: 3545:template <class _Fp, class _A0,
        -: 3546:         class _DecayFp = typename decay<_Fp>::type,
        -: 3547:         class _DecayA0 = typename decay<_A0>::type,
        -: 3548:         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
        -: 3549:using __enable_if_bullet3 = typename enable_if
        -: 3550:    <
        -: 3551:        is_member_function_pointer<_DecayFp>::value
        -: 3552:        && !is_base_of<_ClassT, _DecayA0>::value
        -: 3553:        && !__is_reference_wrapper<_DecayA0>::value
        -: 3554:    >::type;
        -: 3555:
        -: 3556:template <class _Fp, class _A0,
        -: 3557:         class _DecayFp = typename decay<_Fp>::type,
        -: 3558:         class _DecayA0 = typename decay<_A0>::type,
        -: 3559:         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
        -: 3560:using __enable_if_bullet4 = typename enable_if
        -: 3561:    <
        -: 3562:        is_member_object_pointer<_DecayFp>::value
        -: 3563:        && is_base_of<_ClassT, _DecayA0>::value
        -: 3564:    >::type;
        -: 3565:
        -: 3566:template <class _Fp, class _A0,
        -: 3567:         class _DecayFp = typename decay<_Fp>::type,
        -: 3568:         class _DecayA0 = typename decay<_A0>::type>
        -: 3569:using __enable_if_bullet5 = typename enable_if
        -: 3570:    <
        -: 3571:        is_member_object_pointer<_DecayFp>::value
        -: 3572:        && __is_reference_wrapper<_DecayA0>::value
        -: 3573:    >::type;
        -: 3574:
        -: 3575:template <class _Fp, class _A0,
        -: 3576:         class _DecayFp = typename decay<_Fp>::type,
        -: 3577:         class _DecayA0 = typename decay<_A0>::type,
        -: 3578:         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
        -: 3579:using __enable_if_bullet6 = typename enable_if
        -: 3580:    <
        -: 3581:        is_member_object_pointer<_DecayFp>::value
        -: 3582:        && !is_base_of<_ClassT, _DecayA0>::value
        -: 3583:        && !__is_reference_wrapper<_DecayA0>::value
        -: 3584:    >::type;
        -: 3585:
        -: 3586:// __invoke forward declarations
        -: 3587:
        -: 3588:// fall back - none of the bullets
        -: 3589:
        -: 3590:#define _LIBCPP_INVOKE_RETURN(...) \
        -: 3591:    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \
        -: 3592:    { return __VA_ARGS__; }
        -: 3593:
        -: 3594:template <class ..._Args>
        -: 3595:auto __invoke(__any, _Args&& ...__args) -> __nat;
        -: 3596:
        -: 3597:template <class ..._Args>
        -: 3598:auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;
        -: 3599:
        -: 3600:// bullets 1, 2 and 3
        -: 3601:
        -: 3602:template <class _Fp, class _A0, class ..._Args,
        -: 3603:          class = __enable_if_bullet1<_Fp, _A0>>
        -: 3604:inline _LIBCPP_INLINE_VISIBILITY
        -: 3605:_LIBCPP_CONSTEXPR_AFTER_CXX17 auto
        -: 3606:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3607:_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))
        -: 3608:
        -: 3609:template <class _Fp, class _A0, class ..._Args,
        -: 3610:          class = __enable_if_bullet1<_Fp, _A0>>
        -: 3611:inline _LIBCPP_INLINE_VISIBILITY
        -: 3612:_LIBCPP_CONSTEXPR auto
        -: 3613:__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3614:_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))
        -: 3615:
        -: 3616:template <class _Fp, class _A0, class ..._Args,
        -: 3617:          class = __enable_if_bullet2<_Fp, _A0>>
        -: 3618:inline _LIBCPP_INLINE_VISIBILITY
        -: 3619:_LIBCPP_CONSTEXPR_AFTER_CXX17 auto
        -: 3620:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3621:_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))
        -: 3622:
        -: 3623:template <class _Fp, class _A0, class ..._Args,
        -: 3624:          class = __enable_if_bullet2<_Fp, _A0>>
        -: 3625:inline _LIBCPP_INLINE_VISIBILITY
        -: 3626:_LIBCPP_CONSTEXPR auto
        -: 3627:__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3628:_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))
        -: 3629:
        -: 3630:template <class _Fp, class _A0, class ..._Args,
        -: 3631:          class = __enable_if_bullet3<_Fp, _A0>>
        -: 3632:inline _LIBCPP_INLINE_VISIBILITY
        -: 3633:_LIBCPP_CONSTEXPR_AFTER_CXX17 auto
        -: 3634:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3635:_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))
        -: 3636:
        -: 3637:template <class _Fp, class _A0, class ..._Args,
        -: 3638:          class = __enable_if_bullet3<_Fp, _A0>>
        -: 3639:inline _LIBCPP_INLINE_VISIBILITY
        -: 3640:_LIBCPP_CONSTEXPR auto
        -: 3641:__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3642:_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))
        -: 3643:
        -: 3644:// bullets 4, 5 and 6
        -: 3645:
        -: 3646:template <class _Fp, class _A0,
        -: 3647:          class = __enable_if_bullet4<_Fp, _A0>>
        -: 3648:inline _LIBCPP_INLINE_VISIBILITY
        -: 3649:_LIBCPP_CONSTEXPR_AFTER_CXX17 auto
        -: 3650:__invoke(_Fp&& __f, _A0&& __a0)
        -: 3651:_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)
        -: 3652:
        -: 3653:template <class _Fp, class _A0,
        -: 3654:          class = __enable_if_bullet4<_Fp, _A0>>
        -: 3655:inline _LIBCPP_INLINE_VISIBILITY
        -: 3656:_LIBCPP_CONSTEXPR auto
        -: 3657:__invoke_constexpr(_Fp&& __f, _A0&& __a0)
        -: 3658:_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)
        -: 3659:
        -: 3660:template <class _Fp, class _A0,
        -: 3661:          class = __enable_if_bullet5<_Fp, _A0>>
        -: 3662:inline _LIBCPP_INLINE_VISIBILITY
        -: 3663:_LIBCPP_CONSTEXPR_AFTER_CXX17 auto
        -: 3664:__invoke(_Fp&& __f, _A0&& __a0)
        -: 3665:_LIBCPP_INVOKE_RETURN(__a0.get().*__f)
        -: 3666:
        -: 3667:template <class _Fp, class _A0,
        -: 3668:          class = __enable_if_bullet5<_Fp, _A0>>
        -: 3669:inline _LIBCPP_INLINE_VISIBILITY
        -: 3670:_LIBCPP_CONSTEXPR auto
        -: 3671:__invoke_constexpr(_Fp&& __f, _A0&& __a0)
        -: 3672:_LIBCPP_INVOKE_RETURN(__a0.get().*__f)
        -: 3673:
        -: 3674:template <class _Fp, class _A0,
        -: 3675:          class = __enable_if_bullet6<_Fp, _A0>>
        -: 3676:inline _LIBCPP_INLINE_VISIBILITY
        -: 3677:_LIBCPP_CONSTEXPR_AFTER_CXX17 auto
        -: 3678:__invoke(_Fp&& __f, _A0&& __a0)
        -: 3679:_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)
        -: 3680:
        -: 3681:template <class _Fp, class _A0,
        -: 3682:          class = __enable_if_bullet6<_Fp, _A0>>
        -: 3683:inline _LIBCPP_INLINE_VISIBILITY
        -: 3684:_LIBCPP_CONSTEXPR auto
        -: 3685:__invoke_constexpr(_Fp&& __f, _A0&& __a0)
        -: 3686:_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)
        -: 3687:
        -: 3688:// bullet 7
        -: 3689:
        -: 3690:template <class _Fp, class ..._Args>
        -: 3691:inline _LIBCPP_INLINE_VISIBILITY
        -: 3692:_LIBCPP_CONSTEXPR_AFTER_CXX17 auto
        -: 3693:__invoke(_Fp&& __f, _Args&& ...__args)
        -: 3694:_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))
        -: 3695:
        -: 3696:template <class _Fp, class ..._Args>
        -: 3697:inline _LIBCPP_INLINE_VISIBILITY
        -: 3698:_LIBCPP_CONSTEXPR auto
        -: 3699:__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
        -: 3700:_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))
        -: 3701:
        -: 3702:#undef _LIBCPP_INVOKE_RETURN
        -: 3703:
        -: 3704:// __invokable
        -: 3705:template <class _Ret, class _Fp, class ..._Args>
        -: 3706:struct __invokable_r
        -: 3707:{
        -: 3708:  template <class _XFp, class ..._XArgs>
        -: 3709:  static auto __try_call(int) -> decltype(
        -: 3710:    _VSTD::__invoke(_VSTD::declval<_XFp>(), _VSTD::declval<_XArgs>()...));
        -: 3711:  template <class _XFp, class ..._XArgs>
        -: 3712:  static __nat __try_call(...);
        -: 3713:
        -: 3714:  // FIXME: Check that _Ret, _Fp, and _Args... are all complete types, cv void,
        -: 3715:  // or incomplete array types as required by the standard.
        -: 3716:  using _Result = decltype(__try_call<_Fp, _Args...>(0));
        -: 3717:
        -: 3718:  using type =
        -: 3719:  typename conditional<
        -: 3720:      _IsNotSame<_Result, __nat>::value,
        -: 3721:      typename conditional<
        -: 3722:          is_void<_Ret>::value,
        -: 3723:          true_type,
        -: 3724:          is_convertible<_Result, _Ret>
        -: 3725:      >::type,
        -: 3726:      false_type
        -: 3727:  >::type;
        -: 3728:  static const bool value = type::value;
        -: 3729:};
        -: 3730:template <class _Fp, class ..._Args>
        -: 3731:using __invokable = __invokable_r<void, _Fp, _Args...>;
        -: 3732:
        -: 3733:template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
        -: 3734:struct __nothrow_invokable_r_imp {
        -: 3735:  static const bool value = false;
        -: 3736:};
        -: 3737:
        -: 3738:template <class _Ret, class _Fp, class ..._Args>
        -: 3739:struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
        -: 3740:{
        -: 3741:    typedef __nothrow_invokable_r_imp _ThisT;
        -: 3742:
        -: 3743:    template <class _Tp>
        -: 3744:    static void __test_noexcept(_Tp) noexcept;
        -: 3745:
        -: 3746:    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        -: 3747:        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));
        -: 3748:};
        -: 3749:
        -: 3750:template <class _Ret, class _Fp, class ..._Args>
        -: 3751:struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
        -: 3752:{
        -: 3753:    static const bool value = noexcept(
        -: 3754:        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));
        -: 3755:};
        -: 3756:
        -: 3757:template <class _Ret, class _Fp, class ..._Args>
        -: 3758:using __nothrow_invokable_r =
        -: 3759:    __nothrow_invokable_r_imp<
        -: 3760:            __invokable_r<_Ret, _Fp, _Args...>::value,
        -: 3761:            is_void<_Ret>::value,
        -: 3762:            _Ret, _Fp, _Args...
        -: 3763:    >;
        -: 3764:
        -: 3765:template <class _Fp, class ..._Args>
        -: 3766:using __nothrow_invokable =
        -: 3767:    __nothrow_invokable_r_imp<
        -: 3768:            __invokable<_Fp, _Args...>::value,
        -: 3769:            true, void, _Fp, _Args...
        -: 3770:    >;
        -: 3771:
        -: 3772:template <class _Fp, class ..._Args>
        -: 3773:struct __invoke_of
        -: 3774:    : public enable_if<
        -: 3775:        __invokable<_Fp, _Args...>::value,
        -: 3776:        typename __invokable_r<void, _Fp, _Args...>::_Result>
        -: 3777:{
        -: 3778:};
        -: 3779:
        -: 3780:#endif // _LIBCPP_CXX03_LANG
        -: 3781:
        -: 3782:// result_of
        -: 3783:
        -: 3784:template <class _Callable> class result_of;
        -: 3785:
        -: 3786:#ifndef _LIBCPP_CXX03_LANG
        -: 3787:
        -: 3788:template <class _Fp, class ..._Args>
        -: 3789:class _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>
        -: 3790:    : public __invoke_of<_Fp, _Args...>
        -: 3791:{
        -: 3792:};
        -: 3793:
        -: 3794:#else // C++03
        -: 3795:
        -: 3796:template <class _Fn, bool, bool>
        -: 3797:class __result_of
        -: 3798:{
        -: 3799:};
        -: 3800:
        -: 3801:template <class _Fn, class ..._Args>
        -: 3802:class __result_of<_Fn(_Args...), true, false>
        -: 3803:{
        -: 3804:public:
        -: 3805:    typedef decltype(declval<_Fn>()(declval<_Args>()...)) type;
        -: 3806:};
        -: 3807:
        -: 3808:template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
        -: 3809:struct __result_of_mp;
        -: 3810:
        -: 3811:// member function pointer
        -: 3812:
        -: 3813:template <class _MP, class _Tp>
        -: 3814:struct __result_of_mp<_MP, _Tp, true>
        -: 3815:    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>
        -: 3816:{
        -: 3817:};
        -: 3818:
        -: 3819:// member data pointer
        -: 3820:
        -: 3821:template <class _MP, class _Tp, bool>
        -: 3822:struct __result_of_mdp;
        -: 3823:
        -: 3824:template <class _Rp, class _Class, class _Tp>
        -: 3825:struct __result_of_mdp<_Rp _Class::*, _Tp, false>
        -: 3826:{
        -: 3827:    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;
        -: 3828:};
        -: 3829:
        -: 3830:template <class _Rp, class _Class, class _Tp>
        -: 3831:struct __result_of_mdp<_Rp _Class::*, _Tp, true>
        -: 3832:{
        -: 3833:    typedef typename __apply_cv<_Tp, _Rp>::type& type;
        -: 3834:};
        -: 3835:
        -: 3836:template <class _Rp, class _Class, class _Tp>
        -: 3837:struct __result_of_mp<_Rp _Class::*, _Tp, false>
        -: 3838:    : public __result_of_mdp<_Rp _Class::*, _Tp,
        -: 3839:            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
        -: 3840:{
        -: 3841:};
        -: 3842:
        -: 3843:template <class _Fn, class _Tp>
        -: 3844:class __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer
        -: 3845:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 3846:                            _Tp,
        -: 3847:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 3848:{
        -: 3849:};
        -: 3850:
        -: 3851:template <class _Fn, class _Tp, class ..._Args>
        -: 3852:class __result_of<_Fn(_Tp, _Args...), false, true>  // _Fn must be member pointer
        -: 3853:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 3854:                            _Tp,
        -: 3855:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 3856:{
        -: 3857:};
        -: 3858:
        -: 3859:template <class _Fn, class ..._Args>
        -: 3860:class _LIBCPP_TEMPLATE_VIS result_of<_Fn(_Args...)>
        -: 3861:    : public __result_of<_Fn(_Args...),
        -: 3862:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 3863:                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
        -: 3864:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 3865:                        >
        -: 3866:{
        -: 3867:};
        -: 3868:
        -: 3869:#endif  // C++03
        -: 3870:
        -: 3871:#if _LIBCPP_STD_VER > 11
        -: 3872:template <class _Tp> using result_of_t = typename result_of<_Tp>::type;
        -: 3873:#endif
        -: 3874:
        -: 3875:#if _LIBCPP_STD_VER > 14
        -: 3876:
        -: 3877:// invoke_result
        -: 3878:
        -: 3879:template <class _Fn, class... _Args>
        -: 3880:struct _LIBCPP_TEMPLATE_VIS invoke_result
        -: 3881:    : __invoke_of<_Fn, _Args...>
        -: 3882:{
        -: 3883:};
        -: 3884:
        -: 3885:template <class _Fn, class... _Args>
        -: 3886:using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;
        -: 3887:
        -: 3888:// is_invocable
        -: 3889:
        -: 3890:template <class _Fn, class ..._Args>
        -: 3891:struct _LIBCPP_TEMPLATE_VIS is_invocable
        -: 3892:    : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};
        -: 3893:
        -: 3894:template <class _Ret, class _Fn, class ..._Args>
        -: 3895:struct _LIBCPP_TEMPLATE_VIS is_invocable_r
        -: 3896:    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};
        -: 3897:
        -: 3898:template <class _Fn, class ..._Args>
        -: 3899:_LIBCPP_INLINE_VAR constexpr bool is_invocable_v
        -: 3900:    = is_invocable<_Fn, _Args...>::value;
        -: 3901:
        -: 3902:template <class _Ret, class _Fn, class ..._Args>
        -: 3903:_LIBCPP_INLINE_VAR constexpr bool is_invocable_r_v
        -: 3904:    = is_invocable_r<_Ret, _Fn, _Args...>::value;
        -: 3905:
        -: 3906:// is_nothrow_invocable
        -: 3907:
        -: 3908:template <class _Fn, class ..._Args>
        -: 3909:struct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable
        -: 3910:    : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {};
        -: 3911:
        -: 3912:template <class _Ret, class _Fn, class ..._Args>
        -: 3913:struct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable_r
        -: 3914:    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};
        -: 3915:
        -: 3916:template <class _Fn, class ..._Args>
        -: 3917:_LIBCPP_INLINE_VAR constexpr bool is_nothrow_invocable_v
        -: 3918:    = is_nothrow_invocable<_Fn, _Args...>::value;
        -: 3919:
        -: 3920:template <class _Ret, class _Fn, class ..._Args>
        -: 3921:_LIBCPP_INLINE_VAR constexpr bool is_nothrow_invocable_r_v
        -: 3922:    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;
        -: 3923:
        -: 3924:#endif // _LIBCPP_STD_VER > 14
        -: 3925:
        -: 3926:template <class _Tp> struct __is_swappable;
        -: 3927:template <class _Tp> struct __is_nothrow_swappable;
        -: 3928:
        -: 3929:// swap, swap_ranges
        -: 3930:
        -: 3931:template <class _ForwardIterator1, class _ForwardIterator2>
        -: 3932:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
        -: 3933:_ForwardIterator2
        -: 3934:swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);
        -: 3935:
        -: 3936:template <class _Tp>
        -: 3937:inline _LIBCPP_INLINE_VISIBILITY
        -: 3938:#ifndef _LIBCPP_CXX03_LANG
        -: 3939:typename enable_if
        -: 3940:<
        -: 3941:    is_move_constructible<_Tp>::value &&
        -: 3942:    is_move_assignable<_Tp>::value
        -: 3943:>::type
        -: 3944:#else
        -: 3945:void
        -: 3946:#endif
        -: 3947:_LIBCPP_CONSTEXPR_AFTER_CXX17
        -: 3948:swap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&
        -: 3949:                                    is_nothrow_move_assignable<_Tp>::value)
        -: 3950:{
        -: 3951:    _Tp __t(_VSTD::move(__x));
        -: 3952:    __x = _VSTD::move(__y);
        -: 3953:    __y = _VSTD::move(__t);
        -: 3954:}
        -: 3955:
        -: 3956:template<class _Tp, size_t _Np>
        -: 3957:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
        -: 3958:typename enable_if<
        -: 3959:    __is_swappable<_Tp>::value
        -: 3960:>::type
        -: 3961:swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)
        -: 3962:{
        -: 3963:    _VSTD::swap_ranges(__a, __a + _Np, __b);
        -: 3964:}
        -: 3965:
        -: 3966:template <class _ForwardIterator1, class _ForwardIterator2>
        -: 3967:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
        -: 3968:_ForwardIterator2
        -: 3969:swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
        -: 3970:{
        -: 3971:    for(; __first1 != __last1; ++__first1, (void) ++__first2)
        -: 3972:        swap(*__first1, *__first2);
        -: 3973:    return __first2;
        -: 3974:}
        -: 3975:
        -: 3976:// iter_swap
        -: 3977:
        -: 3978:template <class _ForwardIterator1, class _ForwardIterator2>
        -: 3979:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
        -: 3980:void
        -: 3981:iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        -: 3982:    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))
        -: 3983:               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),
        -: 3984:                                          *_VSTD::declval<_ForwardIterator2>())))
        -: 3985:{
        -: 3986:    swap(*__a, *__b);
        -: 3987:}
        -: 3988:
        -: 3989:// __swappable
        -: 3990:
        -: 3991:namespace __detail
        -: 3992:{
        -: 3993:// ALL generic swap overloads MUST already have a declaration available at this point.
        -: 3994:
        -: 3995:template <class _Tp, class _Up = _Tp,
        -: 3996:          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
        -: 3997:struct __swappable_with
        -: 3998:{
        -: 3999:    template <class _LHS, class _RHS>
        -: 4000:    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))
        -: 4001:    __test_swap(int);
        -: 4002:    template <class, class>
        -: 4003:    static __nat __test_swap(long);
        -: 4004:
        -: 4005:    // Extra parens are needed for the C++03 definition of decltype.
        -: 4006:    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
        -: 4007:    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;
        -: 4008:
        -: 4009:    static const bool value = _IsNotSame<__swap1, __nat>::value
        -: 4010:                           && _IsNotSame<__swap2, __nat>::value;
        -: 4011:};
        -: 4012:
        -: 4013:template <class _Tp, class _Up>
        -: 4014:struct __swappable_with<_Tp, _Up,  false> : false_type {};
        -: 4015:
        -: 4016:template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
        -: 4017:struct __nothrow_swappable_with {
        -: 4018:  static const bool value =
        -: 4019:#ifndef _LIBCPP_HAS_NO_NOEXCEPT
        -: 4020:      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))
        -: 4021:  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));
        -: 4022:#else
        -: 4023:      false;
        -: 4024:#endif
        -: 4025:};
        -: 4026:
        -: 4027:template <class _Tp, class _Up>
        -: 4028:struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};
        -: 4029:
        -: 4030:}  // __detail
        -: 4031:
        -: 4032:template <class _Tp>
        -: 4033:struct __is_swappable
        -: 4034:    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
        -: 4035:{
        -: 4036:};
        -: 4037:
        -: 4038:template <class _Tp>
        -: 4039:struct __is_nothrow_swappable
        -: 4040:    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
        -: 4041:{
        -: 4042:};
        -: 4043:
        -: 4044:#if _LIBCPP_STD_VER > 14
        -: 4045:
        -: 4046:template <class _Tp, class _Up>
        -: 4047:struct _LIBCPP_TEMPLATE_VIS is_swappable_with
        -: 4048:    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>
        -: 4049:{
        -: 4050:};
        -: 4051:
        -: 4052:template <class _Tp>
        -: 4053:struct _LIBCPP_TEMPLATE_VIS is_swappable
        -: 4054:    : public conditional<
        -: 4055:        __is_referenceable<_Tp>::value,
        -: 4056:        is_swappable_with<
        -: 4057:            typename add_lvalue_reference<_Tp>::type,
        -: 4058:            typename add_lvalue_reference<_Tp>::type>,
        -: 4059:        false_type
        -: 4060:    >::type
        -: 4061:{
        -: 4062:};
        -: 4063:
        -: 4064:template <class _Tp, class _Up>
        -: 4065:struct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with
        -: 4066:    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>
        -: 4067:{
        -: 4068:};
        -: 4069:
        -: 4070:template <class _Tp>
        -: 4071:struct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable
        -: 4072:    : public conditional<
        -: 4073:        __is_referenceable<_Tp>::value,
        -: 4074:        is_nothrow_swappable_with<
        -: 4075:            typename add_lvalue_reference<_Tp>::type,
        -: 4076:            typename add_lvalue_reference<_Tp>::type>,
        -: 4077:        false_type
        -: 4078:    >::type
        -: 4079:{
        -: 4080:};
        -: 4081:
        -: 4082:template <class _Tp, class _Up>
        -: 4083:_LIBCPP_INLINE_VAR constexpr bool is_swappable_with_v
        -: 4084:    = is_swappable_with<_Tp, _Up>::value;
        -: 4085:
        -: 4086:template <class _Tp>
        -: 4087:_LIBCPP_INLINE_VAR constexpr bool is_swappable_v
        -: 4088:    = is_swappable<_Tp>::value;
        -: 4089:
        -: 4090:template <class _Tp, class _Up>
        -: 4091:_LIBCPP_INLINE_VAR constexpr bool is_nothrow_swappable_with_v
        -: 4092:    = is_nothrow_swappable_with<_Tp, _Up>::value;
        -: 4093:
        -: 4094:template <class _Tp>
        -: 4095:_LIBCPP_INLINE_VAR constexpr bool is_nothrow_swappable_v
        -: 4096:    = is_nothrow_swappable<_Tp>::value;
        -: 4097:
        -: 4098:#endif // _LIBCPP_STD_VER > 14
        -: 4099:
        -: 4100:template <class _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl;
        -: 4101:
        -: 4102:template <class _Tp>
        -: 4103:struct __underlying_type_impl<_Tp, false> {};
        -: 4104:
        -: 4105:template <class _Tp>
        -: 4106:struct __underlying_type_impl<_Tp, true>
        -: 4107:{
        -: 4108:    typedef __underlying_type(_Tp) type;
        -: 4109:};
        -: 4110:
        -: 4111:template <class _Tp>
        -: 4112:struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};
        -: 4113:
        -: 4114:#if _LIBCPP_STD_VER > 11
        -: 4115:template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
        -: 4116:#endif
        -: 4117:
        -: 4118:template <class _Tp, bool = is_enum<_Tp>::value>
        -: 4119:struct __sfinae_underlying_type
        -: 4120:{
        -: 4121:    typedef typename underlying_type<_Tp>::type type;
        -: 4122:    typedef decltype(((type)1) + 0) __promoted_type;
        -: 4123:};
        -: 4124:
        -: 4125:template <class _Tp>
        -: 4126:struct __sfinae_underlying_type<_Tp, false> {};
        -: 4127:
        -: 4128:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4129:int __convert_to_integral(int __val) { return __val; }
        -: 4130:
        -: 4131:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4132:unsigned __convert_to_integral(unsigned __val) { return __val; }
        -: 4133:
        -: 4134:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4135:long __convert_to_integral(long __val) { return __val; }
        -: 4136:
        -: 4137:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4138:unsigned long __convert_to_integral(unsigned long __val) { return __val; }
        -: 4139:
        -: 4140:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4141:long long __convert_to_integral(long long __val) { return __val; }
        -: 4142:
        -: 4143:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4144:unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }
        -: 4145:
        -: 4146:template<typename _Fp>
        -: 4147:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4148:typename enable_if<is_floating_point<_Fp>::value, long long>::type
        -: 4149: __convert_to_integral(_Fp __val) { return __val; }
        -: 4150:
        -: 4151:#ifndef _LIBCPP_HAS_NO_INT128
        -: 4152:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4153:__int128_t __convert_to_integral(__int128_t __val) { return __val; }
        -: 4154:
        -: 4155:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4156:__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }
        -: 4157:#endif
        -: 4158:
        -: 4159:template <class _Tp>
        -: 4160:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -: 4161:typename __sfinae_underlying_type<_Tp>::__promoted_type
        -: 4162:__convert_to_integral(_Tp __val) { return __val; }
        -: 4163:
        -: 4164:#ifndef _LIBCPP_CXX03_LANG
        -: 4165:
        -: 4166:template <class _Tp>
        -: 4167:struct __has_operator_addressof_member_imp
        -: 4168:{
        -: 4169:    template <class _Up>
        -: 4170:        static auto __test(int)
        -: 4171:            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;
        -: 4172:    template <class>
        -: 4173:        static auto __test(long) -> false_type;
        -: 4174:
        -: 4175:    static const bool value = decltype(__test<_Tp>(0))::value;
        -: 4176:};
        -: 4177:
        -: 4178:template <class _Tp>
        -: 4179:struct __has_operator_addressof_free_imp
        -: 4180:{
        -: 4181:    template <class _Up>
        -: 4182:        static auto __test(int)
        -: 4183:            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;
        -: 4184:    template <class>
        -: 4185:        static auto __test(long) -> false_type;
        -: 4186:
        -: 4187:    static const bool value = decltype(__test<_Tp>(0))::value;
        -: 4188:};
        -: 4189:
        -: 4190:template <class _Tp>
        -: 4191:struct __has_operator_addressof
        -: 4192:    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
        -: 4193:                                  || __has_operator_addressof_free_imp<_Tp>::value>
        -: 4194:{};
        -: 4195:
        -: 4196:#endif  // _LIBCPP_CXX03_LANG
        -: 4197:
        -: 4198:// is_scoped_enum [meta.unary.prop]
        -: 4199:
        -: 4200:#if _LIBCPP_STD_VER > 20
        -: 4201:template <class _Tp, bool = is_enum_v<_Tp> >
        -: 4202:struct __is_scoped_enum_helper : false_type {};
        -: 4203:
        -: 4204:template <class _Tp>
        -: 4205:struct __is_scoped_enum_helper<_Tp, true>
        -: 4206:    : public bool_constant<!is_convertible_v<_Tp, underlying_type_t<_Tp> > > {};
        -: 4207:
        -: 4208:template <class _Tp>
        -: 4209:struct _LIBCPP_TEMPLATE_VIS is_scoped_enum
        -: 4210:    : public __is_scoped_enum_helper<_Tp> {};
        -: 4211:
        -: 4212:template <class _Tp>
        -: 4213:_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_scoped_enum_v =
        -: 4214:    is_scoped_enum<_Tp>::value;
        -: 4215:#endif
        -: 4216:
        -: 4217:#if _LIBCPP_STD_VER > 14
        -: 4218:
        -: 4219:template <class... _Args>
        -: 4220:struct conjunction : _And<_Args...> {};
        -: 4221:template<class... _Args>
        -: 4222:_LIBCPP_INLINE_VAR constexpr bool conjunction_v
        -: 4223:    = conjunction<_Args...>::value;
        -: 4224:
        -: 4225:template <class... _Args>
        -: 4226:struct disjunction : _Or<_Args...> {};
        -: 4227:template<class... _Args>
        -: 4228:_LIBCPP_INLINE_VAR constexpr bool disjunction_v
        -: 4229:    = disjunction<_Args...>::value;
        -: 4230:
        -: 4231:template <class _Tp>
        -: 4232:struct negation : _Not<_Tp> {};
        -: 4233:template<class _Tp>
        -: 4234:_LIBCPP_INLINE_VAR constexpr bool negation_v
        -: 4235:    = negation<_Tp>::value;
        -: 4236:#endif  // _LIBCPP_STD_VER > 14
        -: 4237:
        -: 4238:// These traits are used in __tree and __hash_table
        -: 4239:struct __extract_key_fail_tag {};
        -: 4240:struct __extract_key_self_tag {};
        -: 4241:struct __extract_key_first_tag {};
        -: 4242:
        -: 4243:template <class _ValTy, class _Key,
        -: 4244:          class _RawValTy = typename __unconstref<_ValTy>::type>
        -: 4245:struct __can_extract_key
        -: 4246:    : conditional<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag,
        -: 4247:                  __extract_key_fail_tag>::type {};
        -: 4248:
        -: 4249:template <class _Pair, class _Key, class _First, class _Second>
        -: 4250:struct __can_extract_key<_Pair, _Key, pair<_First, _Second> >
        -: 4251:    : conditional<_IsSame<typename remove_const<_First>::type, _Key>::value,
        -: 4252:                  __extract_key_first_tag, __extract_key_fail_tag>::type {};
        -: 4253:
        -: 4254:// __can_extract_map_key uses true_type/false_type instead of the tags.
        -: 4255:// It returns true if _Key != _ContainerValueTy (the container is a map not a set)
        -: 4256:// and _ValTy == _Key.
        -: 4257:template <class _ValTy, class _Key, class _ContainerValueTy,
        -: 4258:          class _RawValTy = typename __unconstref<_ValTy>::type>
        -: 4259:struct __can_extract_map_key
        -: 4260:    : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};
        -: 4261:
        -: 4262:// This specialization returns __extract_key_fail_tag for non-map containers
        -: 4263:// because _Key == _ContainerValueTy
        -: 4264:template <class _ValTy, class _Key, class _RawValTy>
        -: 4265:struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
        -: 4266:    : false_type {};
        -: 4267:
        -: 4268:#ifndef _LIBCPP_HAS_NO_BUILTIN_IS_CONSTANT_EVALUATED
        -: 4269:#if _LIBCPP_STD_VER > 17
        -: 4270:_LIBCPP_INLINE_VISIBILITY
        -: 4271:inline constexpr bool is_constant_evaluated() noexcept {
        -: 4272:  return __builtin_is_constant_evaluated();
        -: 4273:}
        -: 4274:#endif
        -: 4275:
        -: 4276:inline _LIBCPP_CONSTEXPR
        -: 4277:bool __libcpp_is_constant_evaluated() _NOEXCEPT { return __builtin_is_constant_evaluated(); }
        -: 4278:#else
        -: 4279:inline _LIBCPP_CONSTEXPR
        -: 4280:bool __libcpp_is_constant_evaluated() _NOEXCEPT { return false; }
        -: 4281:#endif
        -: 4282:
        -: 4283:template <class _CharT>
        -: 4284:using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;
        -: 4285:
        -: 4286:_LIBCPP_END_NAMESPACE_STD
        -: 4287:
        -: 4288:#if _LIBCPP_STD_VER > 14
        -: 4289:// std::byte
        -: 4290:namespace std  // purposefully not versioned
        -: 4291:{
        -: 4292:
        -: 4293:
        -: 4294:}
        -: 4295:#endif
        -: 4296:
        -: 4297:#endif  // _LIBCPP_TYPE_TRAITS
